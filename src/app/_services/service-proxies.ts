/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    login(payload: LoginViewModel): Observable<ObjectResourceOfLoginResource> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfLoginResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfLoginResource>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ObjectResourceOfLoginResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfLoginResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfLoginResource>(<any>null);
    }

    /**
     * @return OK
     */
    register(payload: RegisterUserVieModel): Observable<ObjectResourceOfRegisterUserResource> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfRegisterUserResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfRegisterUserResource>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ObjectResourceOfRegisterUserResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfRegisterUserResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfRegisterUserResource>(<any>null);
    }

    /**
     * @return OK
     */
    termsandcondition(): Observable<ObjectResourceOfTCResource> {
        let url_ = this.baseUrl + "/api/Account/Termsandcondition";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTermsandcondition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTermsandcondition(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfTCResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfTCResource>><any>_observableThrow(response_);
        }));
    }

    protected processTermsandcondition(response: HttpResponseBase): Observable<ObjectResourceOfTCResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfTCResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfTCResource>(<any>null);
    }

    /**
     * @return OK
     */
    residentialCountries(): Observable<ListResourceOfCountryResource> {
        let url_ = this.baseUrl + "/api/Account/ResidentialCountries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResidentialCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResidentialCountries(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfCountryResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfCountryResource>><any>_observableThrow(response_);
        }));
    }

    protected processResidentialCountries(response: HttpResponseBase): Observable<ListResourceOfCountryResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfCountryResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfCountryResource>(<any>null);
    }

    /**
     * @return OK
     */
    completeProfile(payload: CompleteProfileViewModel): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/Account/CompleteProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteProfile(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteProfile(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    uploadprofilepic(payload: UserPhotoViewModel): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/Account/uploadprofilepic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadprofilepic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadprofilepic(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processUploadprofilepic(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    verifyPhone(payload: VerifiedPhoneUpdate): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/Account/verifyPhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyPhone(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyPhone(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }
}

@Injectable()
export class RegisterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    socialSignup(payload: SocialSignUpViewModel): Observable<ObjectResourceOfRegisterUserResource> {
        let url_ = this.baseUrl + "/api/Account/Register/SocialSignup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSocialSignup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSocialSignup(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfRegisterUserResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfRegisterUserResource>><any>_observableThrow(response_);
        }));
    }

    protected processSocialSignup(response: HttpResponseBase): Observable<ObjectResourceOfRegisterUserResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfRegisterUserResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfRegisterUserResource>(<any>null);
    }
}

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    account(usr: VmUserObj): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usr);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAccount(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return OK
     */
    base(usr: VmUserObj): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Base";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usr);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBase(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processBase(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
    /**
     * @return OK
     */
    localDeliveryTypesGet(id: number): Observable<DeliveryType> {
        let url_ = this.baseUrl + "/api/local-delivery-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocalDeliveryTypesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocalDeliveryTypesGet(<any>response_);
                } catch (e) {
                    return <Observable<DeliveryType>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeliveryType>><any>_observableThrow(response_);
        }));
    }

    protected processLocalDeliveryTypesGet(response: HttpResponseBase): Observable<DeliveryType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeliveryType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeliveryType>(<any>null);
    }

    /**
     * @return No Content
     */
    email(content: string, stacktrace: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Email?";
        if (content === undefined || content === null)
            throw new Error("The parameter 'content' must be defined and cannot be null.");
        else
            url_ += "content=" + encodeURIComponent("" + content) + "&";
        if (stacktrace === undefined || stacktrace === null)
            throw new Error("The parameter 'stacktrace' must be defined and cannot be null.");
        else
            url_ += "stacktrace=" + encodeURIComponent("" + stacktrace) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return OK
     */
    internationalBookingsGet(page: number, booking_status: number, date_range: string, full_name: string): Observable<ObjectResourceOfIPagedListOfInternationalBookingResource> {
        let url_ = this.baseUrl + "/api/InternationalBookings?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (booking_status === undefined || booking_status === null)
            throw new Error("The parameter 'booking_status' must be defined and cannot be null.");
        else
            url_ += "booking_status=" + encodeURIComponent("" + booking_status) + "&";
        if (date_range === undefined || date_range === null)
            throw new Error("The parameter 'date_range' must be defined and cannot be null.");
        else
            url_ += "date_range=" + encodeURIComponent("" + date_range) + "&";
        if (full_name === undefined || full_name === null)
            throw new Error("The parameter 'full_name' must be defined and cannot be null.");
        else
            url_ += "full_name=" + encodeURIComponent("" + full_name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInternationalBookingsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInternationalBookingsGet(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfIPagedListOfInternationalBookingResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfIPagedListOfInternationalBookingResource>><any>_observableThrow(response_);
        }));
    }

    protected processInternationalBookingsGet(response: HttpResponseBase): Observable<ObjectResourceOfIPagedListOfInternationalBookingResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfIPagedListOfInternationalBookingResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfIPagedListOfInternationalBookingResource>(<any>null);
    }

 

    /**
     * @return OK
     */
    internationalBookingsPost(id: number): Observable<ObjectResourceOfInternationalBookingResource> {
        let url_ = this.baseUrl + "/api/InternationalBookings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInternationalBookingsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInternationalBookingsPost(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfInternationalBookingResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfInternationalBookingResource>><any>_observableThrow(response_);
        }));
    }

    protected processInternationalBookingsPost(response: HttpResponseBase): Observable<ObjectResourceOfInternationalBookingResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfInternationalBookingResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfInternationalBookingResource>(<any>null);
    }

    /**
     * @param rate (optional) 
     * @return OK
     */
    intlRoutes(rate: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/intl-routes?";
        if (rate !== undefined && rate !== null)
            url_ += "rate=" + encodeURIComponent("" + rate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntlRoutes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntlRoutes(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processIntlRoutes(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    localBooking(usr: VmUserObj): Observable<boolean> {
        let url_ = this.baseUrl + "/api/LocalBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usr);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocalBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocalBooking(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processLocalBooking(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return OK
     */
    localBookingCategory(): Observable<LocalBookingCategory[]> {
        let url_ = this.baseUrl + "/api/local-booking-category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocalBookingCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocalBookingCategory(<any>response_);
                } catch (e) {
                    return <Observable<LocalBookingCategory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalBookingCategory[]>><any>_observableThrow(response_);
        }));
    }

    protected processLocalBookingCategory(response: HttpResponseBase): Observable<LocalBookingCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LocalBookingCategory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalBookingCategory[]>(<any>null);
    }

    /**
     * @return OK
     */
    locations(): Observable<any> {
        let url_ = this.baseUrl + "/api/locations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocations(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processLocations(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    manage(usr: VmUserObj): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Manage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usr);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManage(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processManage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return OK
     */
    countries(): Observable<ResidentialCountry[]> {
        let url_ = this.baseUrl + "/api/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountries(<any>response_);
                } catch (e) {
                    return <Observable<ResidentialCountry[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResidentialCountry[]>><any>_observableThrow(response_);
        }));
    }

    protected processCountries(response: HttpResponseBase): Observable<ResidentialCountry[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ResidentialCountry.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResidentialCountry[]>(<any>null);
    }

    /**
     * @return OK
     */
    residentialCountry(id: number): Observable<ResidentialCountry> {
        let url_ = this.baseUrl + "/api/ResidentialCountry/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResidentialCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResidentialCountry(<any>response_);
                } catch (e) {
                    return <Observable<ResidentialCountry>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResidentialCountry>><any>_observableThrow(response_);
        }));
    }

    protected processResidentialCountry(response: HttpResponseBase): Observable<ResidentialCountry> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResidentialCountry.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResidentialCountry>(<any>null);
    }
}

@Injectable()
export class AppConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    bookingGet(): Observable<any> {
        let url_ = this.baseUrl + "/api/app-config/booking";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBookingGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookingGet(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processBookingGet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    bookingPost(values: { [key: string]: string; }): Observable<any> {
        let url_ = this.baseUrl + "/api/app-config/booking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(values);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBookingPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookingPost(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processBookingPost(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    partnerFee(): Observable<any> {
        let url_ = this.baseUrl + "/api/app-config/partner-fee";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartnerFee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartnerFee(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPartnerFee(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class BlogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    posts(formData: FormData): Observable<any> {
        let url_ = this.baseUrl + "/api/blog/posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(formData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPosts(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPosts(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class CustomersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    search(q: string): Observable<any> {
        let url_ = this.baseUrl + "/api/customers/search?";
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class DispatcherServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    authenticate(): Observable<any> {
        let url_ = this.baseUrl + "/api/dispatcher/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class VerificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    confirm(): Observable<any> {
        let url_ = this.baseUrl + "/api/dispatcher/verification/confirm";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirm(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processConfirm(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    start(): Observable<any> {
        let url_ = this.baseUrl + "/api/dispatcher/verification/start";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    resend(): Observable<any> {
        let url_ = this.baseUrl + "/api/dispatcher/verification/resend";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResend(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processResend(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class SyncServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    fcmtoken(): Observable<any> {
        let url_ = this.baseUrl + "/api/dispatcher/sync/fcmtoken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFcmtoken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFcmtoken(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processFcmtoken(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class OrdersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    get(): Observable<any> {
        let url_ = this.baseUrl + "/api/dispatcher/orders/get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    bulkprocess(input: SelectedOrder): Observable<any> {
        let url_ = this.baseUrl + "/api/orders/bulkprocess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkprocess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkprocess(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processBulkprocess(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    process(id: number, values: { [key: string]: string; }): Observable<any> {
        let url_ = this.baseUrl + "/api/orders/{id}/process";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(values);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcess(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processProcess(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    dispatch(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/orders/dispatch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDispatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDispatch(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDispatch(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    paid(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/orders/paid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaid(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processPaid(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    delivered(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/orders/delivered";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelivered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelivered(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDelivered(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    reroute(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/orders/reroute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReroute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReroute(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processReroute(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    delivered(): Observable<any> {
        let url_ = this.baseUrl + "/api/dispatcher/order/delivered";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelivered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelivered(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDelivered(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    carryover(): Observable<any> {
        let url_ = this.baseUrl + "/api/dispatcher/order/carryover";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCarryover(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCarryover(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCarryover(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class TemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    upload(): Observable<any> {
        let url_ = this.baseUrl + "/api/email/template/upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class EmailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    template(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/email/template/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTemplate(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processTemplate(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    send(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/email/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class EndpointServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    locations(category: string): Observable<any> {
        let url_ = this.baseUrl + "/api/endpoint/locations?";
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined and cannot be null.");
        else
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocations(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processLocations(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class LocalbookingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    orderdeatil(booking_number: string): Observable<any> {
        let url_ = this.baseUrl + "/api/endpoint/localbooking/orderdeatil?";
        if (booking_number === undefined || booking_number === null)
            throw new Error("The parameter 'booking_number' must be defined and cannot be null.");
        else
            url_ += "booking_number=" + encodeURIComponent("" + booking_number) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrderdeatil(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderdeatil(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processOrderdeatil(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    create(localBooking: CreateLocalBooking): Observable<any> {
        let url_ = this.baseUrl + "/api/endpoint/localbooking/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(localBooking);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class InternationalbookingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    intlbookingstatus(): Observable<ListResourceOfIntlBookingStatusResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/intlbookingstatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntlbookingstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntlbookingstatus(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfIntlBookingStatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfIntlBookingStatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processIntlbookingstatus(response: HttpResponseBase): Observable<ListResourceOfIntlBookingStatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfIntlBookingStatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfIntlBookingStatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    intlbookingbatches(): Observable<ListResourceOfShippingBatchResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/intlbookingbatches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntlbookingbatches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntlbookingbatches(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfShippingBatchResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfShippingBatchResource>><any>_observableThrow(response_);
        }));
    }

    protected processIntlbookingbatches(response: HttpResponseBase): Observable<ListResourceOfShippingBatchResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfShippingBatchResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfShippingBatchResource>(<any>null);
    }

    /**
     * @return OK
     */
    intlbookingshipmentmode(): Observable<ListResourceOfShipmentModeResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/intlbookingshipmentmode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntlbookingshipmentmode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntlbookingshipmentmode(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfShipmentModeResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfShipmentModeResource>><any>_observableThrow(response_);
        }));
    }

    protected processIntlbookingshipmentmode(response: HttpResponseBase): Observable<ListResourceOfShipmentModeResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfShipmentModeResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfShipmentModeResource>(<any>null);
    }

    /**
     * @return OK
     */
    intlbookingdeliverytypes(): Observable<ListResourceOfShipmentDeliveryTypeResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/intlbookingdeliverytypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntlbookingdeliverytypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntlbookingdeliverytypes(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfShipmentDeliveryTypeResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfShipmentDeliveryTypeResource>><any>_observableThrow(response_);
        }));
    }

    protected processIntlbookingdeliverytypes(response: HttpResponseBase): Observable<ListResourceOfShipmentDeliveryTypeResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfShipmentDeliveryTypeResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfShipmentDeliveryTypeResource>(<any>null);
    }

    /**
     * @return OK
     */
    createIntlBooking(internationalBooking: InternationalBookingCtreatDTO): Observable<ObjectResourceOfIntlCreateResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/CreateIntlBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(internationalBooking);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIntlBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIntlBooking(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfIntlCreateResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfIntlCreateResource>><any>_observableThrow(response_);
        }));
    }

    protected processCreateIntlBooking(response: HttpResponseBase): Observable<ObjectResourceOfIntlCreateResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfIntlCreateResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfIntlCreateResource>(<any>null);
    }

    /**
     * @return OK
     */
    prepareholdinstructionfor_create(): Observable<ObjectResourceOfHoldInstructionResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/Prepareholdinstructionfor create";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareholdinstructionfor_create(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareholdinstructionfor_create(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfHoldInstructionResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfHoldInstructionResource>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareholdinstructionfor_create(response: HttpResponseBase): Observable<ObjectResourceOfHoldInstructionResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfHoldInstructionResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfHoldInstructionResource>(<any>null);
    }

    /**
     * @return OK
     */
    createHoldInstruction(holdInstruction: HoldInstructionDTO): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/CreateHoldInstruction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(holdInstruction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHoldInstruction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHoldInstruction(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processCreateHoldInstruction(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    addintlbookingstatus(addStatusViewModel: AddILStatusViewModelDTO): Observable<ObjectResourceOfInternationalBookingResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/addintlbookingstatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addStatusViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddintlbookingstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddintlbookingstatus(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfInternationalBookingResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfInternationalBookingResource>><any>_observableThrow(response_);
        }));
    }

    protected processAddintlbookingstatus(response: HttpResponseBase): Observable<ObjectResourceOfInternationalBookingResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfInternationalBookingResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfInternationalBookingResource>(<any>null);
    }

    /**
     * @return OK
     */
    processIntlBooking(processIL: ProcessILViewModelDTO): Observable<ObjectResourceOfProcessIntlBookingResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/ProcessIntlBooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(processIL);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessIntlBooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessIntlBooking(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfProcessIntlBookingResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfProcessIntlBookingResource>><any>_observableThrow(response_);
        }));
    }

    protected processProcessIntlBooking(response: HttpResponseBase): Observable<ObjectResourceOfProcessIntlBookingResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfProcessIntlBookingResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfProcessIntlBookingResource>(<any>null);
    }

    /**
     * @return OK
     */
    intlBookingstatus(id: number): Observable<ObjectResourceOfInternationalBookingResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/IntlBookingstatus?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntlBookingstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntlBookingstatus(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfInternationalBookingResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfInternationalBookingResource>><any>_observableThrow(response_);
        }));
    }

    protected processIntlBookingstatus(response: HttpResponseBase): Observable<ObjectResourceOfInternationalBookingResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfInternationalBookingResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfInternationalBookingResource>(<any>null);
    }

    /**
     * @return OK
     */
    deleteStatus(id: number): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/DeleteStatus?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStatus(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteStatus(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    deleteIntl(id: number): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/internationalbooking/DeleteIntl?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIntl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIntl(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteIntl(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }
}

@Injectable()
export class InvoicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    update(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/invoices/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class LocalBookingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    getlocalbooking(booking_category: number[], booking_status: number, page: number, dispatcher_id: number, category_group: number, made_by: string, full_name: string, date_range: string, delivery_date: string, booking_number: string, display_mode: string, selected_orders: number[]): Observable<ObjectResourceOfGetLocalBookingsForMobileResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/getlocalbooking?";
        if (booking_category === undefined || booking_category === null)
            throw new Error("The parameter 'booking_category' must be defined and cannot be null.");
        else
            booking_category && booking_category.forEach(item => { url_ += "booking_category=" + encodeURIComponent("" + item) + "&"; });
        if (booking_status === undefined || booking_status === null)
            throw new Error("The parameter 'booking_status' must be defined and cannot be null.");
        else
            url_ += "booking_status=" + encodeURIComponent("" + booking_status) + "&";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (dispatcher_id === undefined || dispatcher_id === null)
            throw new Error("The parameter 'dispatcher_id' must be defined and cannot be null.");
        else
            url_ += "dispatcher_id=" + encodeURIComponent("" + dispatcher_id) + "&";
        if (category_group === undefined || category_group === null)
            throw new Error("The parameter 'category_group' must be defined and cannot be null.");
        else
            url_ += "category_group=" + encodeURIComponent("" + category_group) + "&";
        if (made_by === undefined || made_by === null)
            throw new Error("The parameter 'made_by' must be defined and cannot be null.");
        else
            url_ += "made_by=" + encodeURIComponent("" + made_by) + "&";
        if (full_name === undefined || full_name === null)
            throw new Error("The parameter 'full_name' must be defined and cannot be null.");
        else
            url_ += "full_name=" + encodeURIComponent("" + full_name) + "&";
        if (date_range === undefined || date_range === null)
            throw new Error("The parameter 'date_range' must be defined and cannot be null.");
        else
            url_ += "date_range=" + encodeURIComponent("" + date_range) + "&";
        if (delivery_date === undefined || delivery_date === null)
            throw new Error("The parameter 'delivery_date' must be defined and cannot be null.");
        else
            url_ += "delivery_date=" + encodeURIComponent("" + delivery_date) + "&";
        if (booking_number === undefined || booking_number === null)
            throw new Error("The parameter 'booking_number' must be defined and cannot be null.");
        else
            url_ += "booking_number=" + encodeURIComponent("" + booking_number) + "&";
        if (display_mode === undefined || display_mode === null)
            throw new Error("The parameter 'display_mode' must be defined and cannot be null.");
        else
            url_ += "display_mode=" + encodeURIComponent("" + display_mode) + "&";
        if (selected_orders === undefined || selected_orders === null)
            throw new Error("The parameter 'selected_orders' must be defined and cannot be null.");
        else
            selected_orders && selected_orders.forEach(item => { url_ += "selected_orders=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlocalbooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlocalbooking(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfGetLocalBookingsForMobileResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfGetLocalBookingsForMobileResource>><any>_observableThrow(response_);
        }));
    }

    protected processGetlocalbooking(response: HttpResponseBase): Observable<ObjectResourceOfGetLocalBookingsForMobileResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfGetLocalBookingsForMobileResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfGetLocalBookingsForMobileResource>(<any>null);
    }

    /**
     * @return OK
     */
    localbookingcategorygroup(): Observable<ListResourceOfLocalBookingCategoryResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/localbookingcategorygroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocalbookingcategorygroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocalbookingcategorygroup(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfLocalBookingCategoryResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfLocalBookingCategoryResource>><any>_observableThrow(response_);
        }));
    }

    protected processLocalbookingcategorygroup(response: HttpResponseBase): Observable<ListResourceOfLocalBookingCategoryResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfLocalBookingCategoryResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfLocalBookingCategoryResource>(<any>null);
    }

    /**
     * @return OK
     */
    localbookingstatus(): Observable<ListResourceOfLocalBookingStatusResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/localbookingstatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocalbookingstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocalbookingstatus(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfLocalBookingStatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfLocalBookingStatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processLocalbookingstatus(response: HttpResponseBase): Observable<ListResourceOfLocalBookingStatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfLocalBookingStatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfLocalBookingStatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    localbookingcategory(): Observable<ListResourceOfLocalBookingCategoryGroupResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/localbookingcategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocalbookingcategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocalbookingcategory(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfLocalBookingCategoryGroupResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfLocalBookingCategoryGroupResource>><any>_observableThrow(response_);
        }));
    }

    protected processLocalbookingcategory(response: HttpResponseBase): Observable<ListResourceOfLocalBookingCategoryGroupResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfLocalBookingCategoryGroupResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfLocalBookingCategoryGroupResource>(<any>null);
    }

    /**
     * @return OK
     */
    localbookingdisapatcher(): Observable<ListResourceOfDispatcherResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/localbookingdisapatcher";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocalbookingdisapatcher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocalbookingdisapatcher(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfDispatcherResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfDispatcherResource>><any>_observableThrow(response_);
        }));
    }

    protected processLocalbookingdisapatcher(response: HttpResponseBase): Observable<ListResourceOfDispatcherResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfDispatcherResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfDispatcherResource>(<any>null);
    }

    /**
     * @return OK
     */
    actorstate(): Observable<ListResourceOfCustomerActorResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/actorstate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActorstate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActorstate(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfCustomerActorResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfCustomerActorResource>><any>_observableThrow(response_);
        }));
    }

    protected processActorstate(response: HttpResponseBase): Observable<ListResourceOfCustomerActorResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfCustomerActorResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfCustomerActorResource>(<any>null);
    }

    /**
     * @return OK
     */
    paymenttypes(): Observable<ListResourceOfPaymentTypeResoiurce> {
        let url_ = this.baseUrl + "/api/LocalBooking/paymenttypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymenttypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymenttypes(<any>response_);
                } catch (e) {
                    return <Observable<ListResourceOfPaymentTypeResoiurce>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResourceOfPaymentTypeResoiurce>><any>_observableThrow(response_);
        }));
    }

    protected processPaymenttypes(response: HttpResponseBase): Observable<ListResourceOfPaymentTypeResoiurce> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResourceOfPaymentTypeResoiurce.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResourceOfPaymentTypeResoiurce>(<any>null);
    }

    /**
     * @return OK
     */
    createorder(localBookingDTO: CreateLocalBookingDTO): Observable<ObjectResourceOfLocalBookingResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/createorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(localBookingDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateorder(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfLocalBookingResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfLocalBookingResource>><any>_observableThrow(response_);
        }));
    }

    protected processCreateorder(response: HttpResponseBase): Observable<ObjectResourceOfLocalBookingResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfLocalBookingResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfLocalBookingResource>(<any>null);
    }

    /**
     * @return OK
     */
    localbookingdetail_(id: number): Observable<ObjectResourceOfDetailResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/localbookingdetail /{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocalbookingdetail_(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocalbookingdetail_(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfDetailResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfDetailResource>><any>_observableThrow(response_);
        }));
    }

    protected processLocalbookingdetail_(response: HttpResponseBase): Observable<ObjectResourceOfDetailResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfDetailResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfDetailResource>(<any>null);
    }

    /**
     * @return OK
     */
    editlocalbooking(editLocalBookingViewModel: EditLocalBookingViewModel): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/editlocalbooking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(editLocalBookingViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditlocalbooking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditlocalbooking(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processEditlocalbooking(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    localbookingdelete(id: number): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/localbookingdelete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocalbookingdelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocalbookingdelete(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processLocalbookingdelete(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    modifyOrder(modifyLocalBooking: ModifyLocalBookingViewModel): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/ModifyOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(modifyLocalBooking);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModifyOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModifyOrder(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processModifyOrder(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    cancelOrder(cancelLocalBooking: CancelLocalBookingViewModel): Observable<StatusResource> {
        let url_ = this.baseUrl + "/api/LocalBooking/CancelOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cancelLocalBooking);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelOrder(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processCancelOrder(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }
}

@Injectable()
export class LocalBookingCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    groups(): Observable<LocalBookingCategoryGroup[]> {
        let url_ = this.baseUrl + "/api/local-booking-category/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroups(<any>response_);
                } catch (e) {
                    return <Observable<LocalBookingCategoryGroup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocalBookingCategoryGroup[]>><any>_observableThrow(response_);
        }));
    }

    protected processGroups(response: HttpResponseBase): Observable<LocalBookingCategoryGroup[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LocalBookingCategoryGroup.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocalBookingCategoryGroup[]>(<any>null);
    }

    /**
     * @return No Content
     */
    update(id: number, localBookingCategory: LocalBookingCategory): Observable<void> {
        let url_ = this.baseUrl + "/api/local-booking-category/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(localBookingCategory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return No Content
     */
    update(id: number, localBookingCategoryGroup: LocalBookingCategoryGroup): Observable<void> {
        let url_ = this.baseUrl + "/api/local-booking-category/groups/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(localBookingCategoryGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AssignServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    group(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/local-booking-category/assign/group";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroup(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGroup(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    customizedGroup(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/locations/assign/customized-group";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomizedGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomizedGroup(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCustomizedGroup(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class RouteRateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    delivery_type(from: number, to: number, type: number, booking_category: number): Observable<any> {
        let url_ = this.baseUrl + "/api/route-rate/{from}/{to}/delivery_type/{type}?";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined.");
        url_ = url_.replace("{from}", encodeURIComponent("" + from));
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined.");
        url_ = url_.replace("{to}", encodeURIComponent("" + to));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (booking_category === undefined || booking_category === null)
            throw new Error("The parameter 'booking_category' must be defined and cannot be null.");
        else
            url_ += "booking_category=" + encodeURIComponent("" + booking_category) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelivery_type(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelivery_type(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDelivery_type(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class LocationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    category(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/locations/{id}/category";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategory(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCategory(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    group(id: number, category: number): Observable<any> {
        let url_ = this.baseUrl + "/api/locations/{id}/group/{category}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined.");
        url_ = url_.replace("{category}", encodeURIComponent("" + category));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGroup(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGroup(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    getAuthenticatedUserdatail(): Observable<ObjectResourceOfUserViewModel> {
        let url_ = this.baseUrl + "/GetAuthenticatedUserdatail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthenticatedUserdatail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthenticatedUserdatail(<any>response_);
                } catch (e) {
                    return <Observable<ObjectResourceOfUserViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ObjectResourceOfUserViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuthenticatedUserdatail(response: HttpResponseBase): Observable<ObjectResourceOfUserViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectResourceOfUserViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ObjectResourceOfUserViewModel>(<any>null);
    }

    /**
     * @return OK
     */
    upgradeTopPartner(): Observable<StatusResource> {
        let url_ = this.baseUrl + "/UpgradeTopPartner";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeTopPartner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeTopPartner(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeTopPartner(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    changePassword(model: ChangePasswordViewModel): Observable<StatusResource> {
        let url_ = this.baseUrl + "/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    updateUser(payload: UpdateUserViewModel): Observable<StatusResource> {
        let url_ = this.baseUrl + "/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    forgotpassword(model: ForgotPasswordViewModel): Observable<StatusResource> {
        let url_ = this.baseUrl + "/forgotpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotpassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotpassword(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processForgotpassword(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    sendEmailVerificationCode(): Observable<StatusResource> {
        let url_ = this.baseUrl + "/SendEmailVerificationCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailVerificationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailVerificationCode(<any>response_);
                } catch (e) {
                    return <Observable<StatusResource>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatusResource>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailVerificationCode(response: HttpResponseBase): Observable<StatusResource> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResource.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusResource>(<any>null);
    }

    /**
     * @return OK
     */
    confrimEmail(userId: string, code: string): Observable<any> {
        let url_ = this.baseUrl + "/ConfrimEmail?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfrimEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfrimEmail(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processConfrimEmail(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class MediaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    upload(): Observable<any> {
        let url_ = this.baseUrl + "/api/media/upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    get(page: number): Observable<any> {
        let url_ = this.baseUrl + "/api/media/get?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class UploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    files(): Observable<any> {
        let url_ = this.baseUrl + "/api/media/upload/files";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFiles(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processFiles(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    cv(): Observable<any> {
        let url_ = this.baseUrl + "/api/media/upload/cv";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCv(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCv(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    company_logo(): Observable<any> {
        let url_ = this.baseUrl + "/api/media/upload/company_logo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompany_logo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompany_logo(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCompany_logo(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class IntlServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    add_shipping_batch(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/orders/intl/add_shipping_batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd_shipping_batch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd_shipping_batch(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processAdd_shipping_batch(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    add_status(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/orders/intl/add_status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd_status(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd_status(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processAdd_status(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class Shipping_batchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    add(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/orders/intl/shipping_batch/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    dashboard(filter: string): Observable<any> {
        let url_ = this.baseUrl + "/api/report/dashboard/{filter}";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined.");
        url_ = url_.replace("{filter}", encodeURIComponent("" + filter));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDashboard(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDashboard(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class RevenueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    local(filter: string): Observable<any> {
        let url_ = this.baseUrl + "/api/report/revenue/local/{filter}";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined.");
        url_ = url_.replace("{filter}", encodeURIComponent("" + filter));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLocal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLocal(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processLocal(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    intl(filter: string): Observable<any> {
        let url_ = this.baseUrl + "/api/report/revenue/intl/{filter}";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined.");
        url_ = url_.replace("{filter}", encodeURIComponent("" + filter));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIntl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIntl(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processIntl(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class CountriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    states(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/countries/{id}/states";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStates(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processStates(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class SmsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://40.91.215.240:8008";
    }

    /**
     * @return OK
     */
    smsTemplate(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/sms/sms-template/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSmsTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSmsTemplate(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSmsTemplate(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return OK
     */
    send(data: { [key: string]: any; }): Observable<any> {
        let url_ = this.baseUrl + "/api/sms/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

export class LoginViewModel implements ILoginViewModel {
    email: string;
    password: string;
    rememberMe: boolean | undefined;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data; 
    }

    clone(): LoginViewModel {
        const json = this.toJSON();
        let result = new LoginViewModel();
        result.init(json);
        return result;
    }
}

export interface ILoginViewModel {
    email: string;
    password: string;
    rememberMe: boolean | undefined;
}

export class ObjectResourceOfLoginResource implements IObjectResourceOfLoginResource {
    data: LoginResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfLoginResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LoginResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfLoginResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfLoginResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfLoginResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfLoginResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfLoginResource {
    data: LoginResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class LoginResource implements ILoginResource {
    token: string | undefined;
    userId: string | undefined;
    userType: LoginResourceUserType | undefined;
    isProfileComplete: boolean | undefined;
    user: AspNetUser | undefined;
    role: AspNetRole[] | undefined;
    customer: Customer | undefined;

    constructor(data?: ILoginResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.userType = _data["userType"];
            this.isProfileComplete = _data["isProfileComplete"];
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["role"])) {
                this.role = [] as any;
                for (let item of _data["role"])
                    this.role.push(AspNetRole.fromJS(item));
            }
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoginResource {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["userType"] = this.userType;
        data["isProfileComplete"] = this.isProfileComplete;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.role)) {
            data["role"] = [];
            for (let item of this.role)
                data["role"].push(item.toJSON());
        }
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): LoginResource {
        const json = this.toJSON();
        let result = new LoginResource();
        result.init(json);
        return result;
    }
}

export interface ILoginResource {
    token: string | undefined;
    userId: string | undefined;
    userType: LoginResourceUserType | undefined;
    isProfileComplete: boolean | undefined;
    user: AspNetUser | undefined;
    role: AspNetRole[] | undefined;
    customer: Customer | undefined;
}

export class AspNetUser implements IAspNetUser {
    email: string | undefined;
    userName: string;

    constructor(data?: IAspNetUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): AspNetUser {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): AspNetUser {
        const json = this.toJSON();
        let result = new AspNetUser();
        result.init(json);
        return result;
    }
}

export interface IAspNetUser {
    email: string | undefined;
    userName: string;
}

export class AspNetRole implements IAspNetRole {
    name: string;
    aspNetUsers: AspNetUser[] | undefined;

    constructor(data?: IAspNetRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["aspNetUsers"])) {
                this.aspNetUsers = [] as any;
                for (let item of _data["aspNetUsers"])
                    this.aspNetUsers.push(AspNetUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AspNetRole {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.aspNetUsers)) {
            data["aspNetUsers"] = [];
            for (let item of this.aspNetUsers)
                data["aspNetUsers"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AspNetRole {
        const json = this.toJSON();
        let result = new AspNetRole();
        result.init(json);
        return result;
    }
}

export interface IAspNetRole {
    name: string;
    aspNetUsers: AspNetUser[] | undefined;
}

export class Customer implements ICustomer {
    userId: string | undefined;
    fullName: string | undefined;
    closestLandmark: string | undefined;
    closestBustopId: number | undefined;
    registerAsPartner: boolean | undefined;
    homeAddress: string | undefined;
    businessName: string | undefined;
    companyLogo: string | undefined;
    residentialCountryId: number | undefined;
    residentialStateId: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    businessAnniversary: moment.Moment | undefined;
    aspNetUser: AspNetUser | undefined;
    wallet: Wallet | undefined;
    residentialCountry: ResidentialCountry | undefined;
    residentialState: ResidentialState | undefined;
    location: Location | undefined;
    synergyProgramCustomer: SynergyProgramCustomer | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.fullName = _data["fullName"];
            this.closestLandmark = _data["closestLandmark"];
            this.closestBustopId = _data["closestBustopId"];
            this.registerAsPartner = _data["registerAsPartner"];
            this.homeAddress = _data["homeAddress"];
            this.businessName = _data["businessName"];
            this.companyLogo = _data["companyLogo"];
            this.residentialCountryId = _data["residentialCountryId"];
            this.residentialStateId = _data["residentialStateId"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.businessAnniversary = _data["businessAnniversary"] ? moment(_data["businessAnniversary"].toString()) : <any>undefined;
            this.aspNetUser = _data["aspNetUser"] ? AspNetUser.fromJS(_data["aspNetUser"]) : <any>undefined;
            this.wallet = _data["wallet"] ? Wallet.fromJS(_data["wallet"]) : <any>undefined;
            this.residentialCountry = _data["residentialCountry"] ? ResidentialCountry.fromJS(_data["residentialCountry"]) : <any>undefined;
            this.residentialState = _data["residentialState"] ? ResidentialState.fromJS(_data["residentialState"]) : <any>undefined;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>undefined;
            this.synergyProgramCustomer = _data["synergyProgramCustomer"] ? SynergyProgramCustomer.fromJS(_data["synergyProgramCustomer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["fullName"] = this.fullName;
        data["closestLandmark"] = this.closestLandmark;
        data["closestBustopId"] = this.closestBustopId;
        data["registerAsPartner"] = this.registerAsPartner;
        data["homeAddress"] = this.homeAddress;
        data["businessName"] = this.businessName;
        data["companyLogo"] = this.companyLogo;
        data["residentialCountryId"] = this.residentialCountryId;
        data["residentialStateId"] = this.residentialStateId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["businessAnniversary"] = this.businessAnniversary ? this.businessAnniversary.toISOString() : <any>undefined;
        data["aspNetUser"] = this.aspNetUser ? this.aspNetUser.toJSON() : <any>undefined;
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>undefined;
        data["residentialCountry"] = this.residentialCountry ? this.residentialCountry.toJSON() : <any>undefined;
        data["residentialState"] = this.residentialState ? this.residentialState.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["synergyProgramCustomer"] = this.synergyProgramCustomer ? this.synergyProgramCustomer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Customer {
        const json = this.toJSON();
        let result = new Customer();
        result.init(json);
        return result;
    }
}

export interface ICustomer {
    userId: string | undefined;
    fullName: string | undefined;
    closestLandmark: string | undefined;
    closestBustopId: number | undefined;
    registerAsPartner: boolean | undefined;
    homeAddress: string | undefined;
    businessName: string | undefined;
    companyLogo: string | undefined;
    residentialCountryId: number | undefined;
    residentialStateId: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    businessAnniversary: moment.Moment | undefined;
    aspNetUser: AspNetUser | undefined;
    wallet: Wallet | undefined;
    residentialCountry: ResidentialCountry | undefined;
    residentialState: ResidentialState | undefined;
    location: Location | undefined;
    synergyProgramCustomer: SynergyProgramCustomer | undefined;
}

export class Wallet implements IWallet {
    userId: string | undefined;
    isActive: boolean | undefined;
    customer: Customer | undefined;
    balance: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    walletPayments: WalletPayment[] | undefined;
    walletCredits: WalletCredit[] | undefined;

    constructor(data?: IWallet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.isActive = _data["isActive"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.balance = _data["balance"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["walletPayments"])) {
                this.walletPayments = [] as any;
                for (let item of _data["walletPayments"])
                    this.walletPayments.push(WalletPayment.fromJS(item));
            }
            if (Array.isArray(_data["walletCredits"])) {
                this.walletCredits = [] as any;
                for (let item of _data["walletCredits"])
                    this.walletCredits.push(WalletCredit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Wallet {
        data = typeof data === 'object' ? data : {};
        let result = new Wallet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["isActive"] = this.isActive;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.walletPayments)) {
            data["walletPayments"] = [];
            for (let item of this.walletPayments)
                data["walletPayments"].push(item.toJSON());
        }
        if (Array.isArray(this.walletCredits)) {
            data["walletCredits"] = [];
            for (let item of this.walletCredits)
                data["walletCredits"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Wallet {
        const json = this.toJSON();
        let result = new Wallet();
        result.init(json);
        return result;
    }
}

export interface IWallet {
    userId: string | undefined;
    isActive: boolean | undefined;
    customer: Customer | undefined;
    balance: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    walletPayments: WalletPayment[] | undefined;
    walletCredits: WalletCredit[] | undefined;
}

export class ResidentialCountry implements IResidentialCountry {
    id: number | undefined;
    name: string;
    countryCode: string | undefined;
    residentialStates: ResidentialState[] | undefined;

    constructor(data?: IResidentialCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.countryCode = _data["countryCode"];
            if (Array.isArray(_data["residentialStates"])) {
                this.residentialStates = [] as any;
                for (let item of _data["residentialStates"])
                    this.residentialStates.push(ResidentialState.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResidentialCountry {
        data = typeof data === 'object' ? data : {};
        let result = new ResidentialCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["countryCode"] = this.countryCode;
        if (Array.isArray(this.residentialStates)) {
            data["residentialStates"] = [];
            for (let item of this.residentialStates)
                data["residentialStates"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ResidentialCountry {
        const json = this.toJSON();
        let result = new ResidentialCountry();
        result.init(json);
        return result;
    }
}

export interface IResidentialCountry {
    id: number | undefined;
    name: string;
    countryCode: string | undefined;
    residentialStates: ResidentialState[] | undefined;
}

export class ResidentialState implements IResidentialState {
    id: number | undefined;
    name: string;
    residentialCountryId: number | undefined;

    constructor(data?: IResidentialState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.residentialCountryId = _data["residentialCountryId"];
        }
    }

    static fromJS(data: any): ResidentialState {
        data = typeof data === 'object' ? data : {};
        let result = new ResidentialState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["residentialCountryId"] = this.residentialCountryId;
        return data; 
    }

    clone(): ResidentialState {
        const json = this.toJSON();
        let result = new ResidentialState();
        result.init(json);
        return result;
    }
}

export interface IResidentialState {
    id: number | undefined;
    name: string;
    residentialCountryId: number | undefined;
}

export class Location implements ILocation {
    id: number | undefined;
    name: string;
    localBookingCategoryId: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    localBookingCategory: LocalBookingCategory | undefined;
    locationRatesGroupId: number | undefined;
    isActive: boolean | undefined;
    locationRatesGroup: LocationRatesGroup | undefined;
    localBookingsForPickup: LocalBooking[] | undefined;
    localBookingsForDelivery: LocalBooking[] | undefined;
    customizedLocationGroups: CustomizedLocationGroup[] | undefined;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.localBookingCategoryId = _data["localBookingCategoryId"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.localBookingCategory = _data["localBookingCategory"] ? LocalBookingCategory.fromJS(_data["localBookingCategory"]) : <any>undefined;
            this.locationRatesGroupId = _data["locationRatesGroupId"];
            this.isActive = _data["isActive"];
            this.locationRatesGroup = _data["locationRatesGroup"] ? LocationRatesGroup.fromJS(_data["locationRatesGroup"]) : <any>undefined;
            if (Array.isArray(_data["localBookingsForPickup"])) {
                this.localBookingsForPickup = [] as any;
                for (let item of _data["localBookingsForPickup"])
                    this.localBookingsForPickup.push(LocalBooking.fromJS(item));
            }
            if (Array.isArray(_data["localBookingsForDelivery"])) {
                this.localBookingsForDelivery = [] as any;
                for (let item of _data["localBookingsForDelivery"])
                    this.localBookingsForDelivery.push(LocalBooking.fromJS(item));
            }
            if (Array.isArray(_data["customizedLocationGroups"])) {
                this.customizedLocationGroups = [] as any;
                for (let item of _data["customizedLocationGroups"])
                    this.customizedLocationGroups.push(CustomizedLocationGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["localBookingCategoryId"] = this.localBookingCategoryId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["localBookingCategory"] = this.localBookingCategory ? this.localBookingCategory.toJSON() : <any>undefined;
        data["locationRatesGroupId"] = this.locationRatesGroupId;
        data["isActive"] = this.isActive;
        data["locationRatesGroup"] = this.locationRatesGroup ? this.locationRatesGroup.toJSON() : <any>undefined;
        if (Array.isArray(this.localBookingsForPickup)) {
            data["localBookingsForPickup"] = [];
            for (let item of this.localBookingsForPickup)
                data["localBookingsForPickup"].push(item.toJSON());
        }
        if (Array.isArray(this.localBookingsForDelivery)) {
            data["localBookingsForDelivery"] = [];
            for (let item of this.localBookingsForDelivery)
                data["localBookingsForDelivery"].push(item.toJSON());
        }
        if (Array.isArray(this.customizedLocationGroups)) {
            data["customizedLocationGroups"] = [];
            for (let item of this.customizedLocationGroups)
                data["customizedLocationGroups"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Location {
        const json = this.toJSON();
        let result = new Location();
        result.init(json);
        return result;
    }
}

export interface ILocation {
    id: number | undefined;
    name: string;
    localBookingCategoryId: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    localBookingCategory: LocalBookingCategory | undefined;
    locationRatesGroupId: number | undefined;
    isActive: boolean | undefined;
    locationRatesGroup: LocationRatesGroup | undefined;
    localBookingsForPickup: LocalBooking[] | undefined;
    localBookingsForDelivery: LocalBooking[] | undefined;
    customizedLocationGroups: CustomizedLocationGroup[] | undefined;
}

export class SynergyProgramCustomer implements ISynergyProgramCustomer {
    userId: string | undefined;
    createdAt: moment.Moment | undefined;
    isApproved: boolean | undefined;
    updatedAt: moment.Moment | undefined;
    approvedAt: moment.Moment | undefined;
    approvedByUserId: string | undefined;
    approvedBy: AspNetUser | undefined;
    customer: Customer | undefined;

    constructor(data?: ISynergyProgramCustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.isApproved = _data["isApproved"];
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.approvedAt = _data["approvedAt"] ? moment(_data["approvedAt"].toString()) : <any>undefined;
            this.approvedByUserId = _data["approvedByUserId"];
            this.approvedBy = _data["approvedBy"] ? AspNetUser.fromJS(_data["approvedBy"]) : <any>undefined;
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SynergyProgramCustomer {
        data = typeof data === 'object' ? data : {};
        let result = new SynergyProgramCustomer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["isApproved"] = this.isApproved;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["approvedAt"] = this.approvedAt ? this.approvedAt.toISOString() : <any>undefined;
        data["approvedByUserId"] = this.approvedByUserId;
        data["approvedBy"] = this.approvedBy ? this.approvedBy.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SynergyProgramCustomer {
        const json = this.toJSON();
        let result = new SynergyProgramCustomer();
        result.init(json);
        return result;
    }
}

export interface ISynergyProgramCustomer {
    userId: string | undefined;
    createdAt: moment.Moment | undefined;
    isApproved: boolean | undefined;
    updatedAt: moment.Moment | undefined;
    approvedAt: moment.Moment | undefined;
    approvedByUserId: string | undefined;
    approvedBy: AspNetUser | undefined;
    customer: Customer | undefined;
}

export class WalletPayment implements IWalletPayment {
    id: number | undefined;
    paymentGatewayId: number | undefined;
    transactionId: string | undefined;
    transactionReference: string | undefined;
    totalAmount: number | undefined;
    currency: string | undefined;
    paymentStatusId: number | undefined;
    walletUserId: string | undefined;
    isUsed: boolean | undefined;
    paymentGateway: PaymentGateway | undefined;
    paymentStatus: PaymentStatus | undefined;
    wallet: Wallet | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;

    constructor(data?: IWalletPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentGatewayId = _data["paymentGatewayId"];
            this.transactionId = _data["transactionId"];
            this.transactionReference = _data["transactionReference"];
            this.totalAmount = _data["totalAmount"];
            this.currency = _data["currency"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.walletUserId = _data["walletUserId"];
            this.isUsed = _data["isUsed"];
            this.paymentGateway = _data["paymentGateway"] ? PaymentGateway.fromJS(_data["paymentGateway"]) : <any>undefined;
            this.paymentStatus = _data["paymentStatus"] ? PaymentStatus.fromJS(_data["paymentStatus"]) : <any>undefined;
            this.wallet = _data["wallet"] ? Wallet.fromJS(_data["wallet"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletPayment {
        data = typeof data === 'object' ? data : {};
        let result = new WalletPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentGatewayId"] = this.paymentGatewayId;
        data["transactionId"] = this.transactionId;
        data["transactionReference"] = this.transactionReference;
        data["totalAmount"] = this.totalAmount;
        data["currency"] = this.currency;
        data["paymentStatusId"] = this.paymentStatusId;
        data["walletUserId"] = this.walletUserId;
        data["isUsed"] = this.isUsed;
        data["paymentGateway"] = this.paymentGateway ? this.paymentGateway.toJSON() : <any>undefined;
        data["paymentStatus"] = this.paymentStatus ? this.paymentStatus.toJSON() : <any>undefined;
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }

    clone(): WalletPayment {
        const json = this.toJSON();
        let result = new WalletPayment();
        result.init(json);
        return result;
    }
}

export interface IWalletPayment {
    id: number | undefined;
    paymentGatewayId: number | undefined;
    transactionId: string | undefined;
    transactionReference: string | undefined;
    totalAmount: number | undefined;
    currency: string | undefined;
    paymentStatusId: number | undefined;
    walletUserId: string | undefined;
    isUsed: boolean | undefined;
    paymentGateway: PaymentGateway | undefined;
    paymentStatus: PaymentStatus | undefined;
    wallet: Wallet | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
}

export class WalletCredit implements IWalletCredit {
    id: number | undefined;
    walletId: string | undefined;
    amount: number | undefined;
    isPaid: boolean | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    wallet: Wallet | undefined;

    constructor(data?: IWalletCredit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.walletId = _data["walletId"];
            this.amount = _data["amount"];
            this.isPaid = _data["isPaid"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.wallet = _data["wallet"] ? Wallet.fromJS(_data["wallet"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletCredit {
        data = typeof data === 'object' ? data : {};
        let result = new WalletCredit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["walletId"] = this.walletId;
        data["amount"] = this.amount;
        data["isPaid"] = this.isPaid;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>undefined;
        return data; 
    }

    clone(): WalletCredit {
        const json = this.toJSON();
        let result = new WalletCredit();
        result.init(json);
        return result;
    }
}

export interface IWalletCredit {
    id: number | undefined;
    walletId: string | undefined;
    amount: number | undefined;
    isPaid: boolean | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    wallet: Wallet | undefined;
}

export class LocalBookingCategory implements ILocalBookingCategory {
    id: number | undefined;
    name: string;
    toggleBookingActivation: boolean | undefined;
    locations: Location[] | undefined;
    localBookings: LocalBooking[] | undefined;

    constructor(data?: ILocalBookingCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.toggleBookingActivation = _data["toggleBookingActivation"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations.push(Location.fromJS(item));
            }
            if (Array.isArray(_data["localBookings"])) {
                this.localBookings = [] as any;
                for (let item of _data["localBookings"])
                    this.localBookings.push(LocalBooking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalBookingCategory {
        data = typeof data === 'object' ? data : {};
        let result = new LocalBookingCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["toggleBookingActivation"] = this.toggleBookingActivation;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.localBookings)) {
            data["localBookings"] = [];
            for (let item of this.localBookings)
                data["localBookings"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocalBookingCategory {
        const json = this.toJSON();
        let result = new LocalBookingCategory();
        result.init(json);
        return result;
    }
}

export interface ILocalBookingCategory {
    id: number | undefined;
    name: string;
    toggleBookingActivation: boolean | undefined;
    locations: Location[] | undefined;
    localBookings: LocalBooking[] | undefined;
}

export class LocationRatesGroup implements ILocationRatesGroup {
    id: number | undefined;
    name: string;
    locations: Location[] | undefined;
    fromLocalRouteRates: LocalRouteRate[] | undefined;
    toLocalRouteRates: LocalRouteRate[] | undefined;
    localBookingCategoryGroups: LocalBookingCategoryGroup[] | undefined;

    constructor(data?: ILocationRatesGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations.push(Location.fromJS(item));
            }
            if (Array.isArray(_data["fromLocalRouteRates"])) {
                this.fromLocalRouteRates = [] as any;
                for (let item of _data["fromLocalRouteRates"])
                    this.fromLocalRouteRates.push(LocalRouteRate.fromJS(item));
            }
            if (Array.isArray(_data["toLocalRouteRates"])) {
                this.toLocalRouteRates = [] as any;
                for (let item of _data["toLocalRouteRates"])
                    this.toLocalRouteRates.push(LocalRouteRate.fromJS(item));
            }
            if (Array.isArray(_data["localBookingCategoryGroups"])) {
                this.localBookingCategoryGroups = [] as any;
                for (let item of _data["localBookingCategoryGroups"])
                    this.localBookingCategoryGroups.push(LocalBookingCategoryGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocationRatesGroup {
        data = typeof data === 'object' ? data : {};
        let result = new LocationRatesGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        if (Array.isArray(this.fromLocalRouteRates)) {
            data["fromLocalRouteRates"] = [];
            for (let item of this.fromLocalRouteRates)
                data["fromLocalRouteRates"].push(item.toJSON());
        }
        if (Array.isArray(this.toLocalRouteRates)) {
            data["toLocalRouteRates"] = [];
            for (let item of this.toLocalRouteRates)
                data["toLocalRouteRates"].push(item.toJSON());
        }
        if (Array.isArray(this.localBookingCategoryGroups)) {
            data["localBookingCategoryGroups"] = [];
            for (let item of this.localBookingCategoryGroups)
                data["localBookingCategoryGroups"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocationRatesGroup {
        const json = this.toJSON();
        let result = new LocationRatesGroup();
        result.init(json);
        return result;
    }
}

export interface ILocationRatesGroup {
    id: number | undefined;
    name: string;
    locations: Location[] | undefined;
    fromLocalRouteRates: LocalRouteRate[] | undefined;
    toLocalRouteRates: LocalRouteRate[] | undefined;
    localBookingCategoryGroups: LocalBookingCategoryGroup[] | undefined;
}

export class LocalBooking implements ILocalBooking {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    deliveryDate: moment.Moment;
    deliveryTypeId: number | undefined;
    deliveryType: DeliveryType | undefined;
    paymentTypeId: number;
    bookingStatusId: number | undefined;
    isAccepted: boolean | undefined;
    isRejected: boolean | undefined;
    isDispatched: boolean | undefined;
    isDelivered: boolean | undefined;
    isPaid: boolean | undefined;
    bookingNumber: string | undefined;
    bookingStatus: BookingStatus | undefined;
    paymentType: PaymentType | undefined;
    acceptanceNote: string | undefined;
    dispatchNote: string | undefined;
    rejectionNote: string | undefined;
    dispatcherId: number | undefined;
    dispatcher: Dispatcher | undefined;
    localRouteRateId: number | undefined;
    localRouteRate: LocalRouteRate | undefined;
    senderName: string;
    pickUpAddress: string;
    pickupLandmark: string | undefined;
    phoneNumber: string;
    actorPhoneNumber: string | undefined;
    recipientName: string;
    deliveryAddress: string;
    deliveryLandmark: string | undefined;
    recipientPhoneNumber: string;
    pickupLocationId: number | undefined;
    deliveryLocationId: number | undefined;
    pickupLocation: Location | undefined;
    deliveryLocation: Location | undefined;
    packageDescription: string | undefined;
    sizeDescription: string | undefined;
    isInsured: boolean | undefined;
    packageValue: number | undefined;
    deliveryCost: number | undefined;
    numberOfPackages: number | undefined;
    insuranceCost: number | undefined;
    totalCost: number | undefined;
    localBookingCategoryId: number | undefined;
    localBookingCategory: LocalBookingCategory | undefined;
    estimatedPackageWeight: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    deletedAt: moment.Moment | undefined;
    customerActorStateId: number | undefined;
    bulkOrderId: number | undefined;
    customerActorState: CustomerActorState | undefined;
    payments: Payment[] | undefined;
    bulkOrder: BulkOrder | undefined;
    enableCustomerCancel: boolean | undefined;
    email: string | undefined;
    dispatchRouteStatus: DispatchRouteStatus[] | undefined;
    bookedByPartner: boolean | undefined;
    wantCashCollection: boolean | undefined;
    cashCollectionAmount: number | undefined;
    cashCollectionAccountNumber: string | undefined;
    dispatchedAt: moment.Moment | undefined;
    deliveredAt: moment.Moment | undefined;
    createdFromEndpoint: boolean | undefined;
    personalizedLocalRateId: number | undefined;
    personalizedLocalRate: PersonalizedLocalRate | undefined;

    constructor(data?: ILocalBooking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.deliveryDate = _data["deliveryDate"] ? moment(_data["deliveryDate"].toString()) : <any>undefined;
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.deliveryType = _data["deliveryType"] ? DeliveryType.fromJS(_data["deliveryType"]) : <any>undefined;
            this.paymentTypeId = _data["paymentTypeId"];
            this.bookingStatusId = _data["bookingStatusId"];
            this.isAccepted = _data["isAccepted"];
            this.isRejected = _data["isRejected"];
            this.isDispatched = _data["isDispatched"];
            this.isDelivered = _data["isDelivered"];
            this.isPaid = _data["isPaid"];
            this.bookingNumber = _data["bookingNumber"];
            this.bookingStatus = _data["bookingStatus"] ? BookingStatus.fromJS(_data["bookingStatus"]) : <any>undefined;
            this.paymentType = _data["paymentType"] ? PaymentType.fromJS(_data["paymentType"]) : <any>undefined;
            this.acceptanceNote = _data["acceptanceNote"];
            this.dispatchNote = _data["dispatchNote"];
            this.rejectionNote = _data["rejectionNote"];
            this.dispatcherId = _data["dispatcherId"];
            this.dispatcher = _data["dispatcher"] ? Dispatcher.fromJS(_data["dispatcher"]) : <any>undefined;
            this.localRouteRateId = _data["localRouteRateId"];
            this.localRouteRate = _data["localRouteRate"] ? LocalRouteRate.fromJS(_data["localRouteRate"]) : <any>undefined;
            this.senderName = _data["senderName"];
            this.pickUpAddress = _data["pickUpAddress"];
            this.pickupLandmark = _data["pickupLandmark"];
            this.phoneNumber = _data["phoneNumber"];
            this.actorPhoneNumber = _data["actorPhoneNumber"];
            this.recipientName = _data["recipientName"];
            this.deliveryAddress = _data["deliveryAddress"];
            this.deliveryLandmark = _data["deliveryLandmark"];
            this.recipientPhoneNumber = _data["recipientPhoneNumber"];
            this.pickupLocationId = _data["pickupLocationId"];
            this.deliveryLocationId = _data["deliveryLocationId"];
            this.pickupLocation = _data["pickupLocation"] ? Location.fromJS(_data["pickupLocation"]) : <any>undefined;
            this.deliveryLocation = _data["deliveryLocation"] ? Location.fromJS(_data["deliveryLocation"]) : <any>undefined;
            this.packageDescription = _data["packageDescription"];
            this.sizeDescription = _data["sizeDescription"];
            this.isInsured = _data["isInsured"];
            this.packageValue = _data["packageValue"];
            this.deliveryCost = _data["deliveryCost"];
            this.numberOfPackages = _data["numberOfPackages"];
            this.insuranceCost = _data["insuranceCost"];
            this.totalCost = _data["totalCost"];
            this.localBookingCategoryId = _data["localBookingCategoryId"];
            this.localBookingCategory = _data["localBookingCategory"] ? LocalBookingCategory.fromJS(_data["localBookingCategory"]) : <any>undefined;
            this.estimatedPackageWeight = _data["estimatedPackageWeight"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.customerActorStateId = _data["customerActorStateId"];
            this.bulkOrderId = _data["bulkOrderId"];
            this.customerActorState = _data["customerActorState"] ? CustomerActorState.fromJS(_data["customerActorState"]) : <any>undefined;
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments.push(Payment.fromJS(item));
            }
            this.bulkOrder = _data["bulkOrder"] ? BulkOrder.fromJS(_data["bulkOrder"]) : <any>undefined;
            this.enableCustomerCancel = _data["enableCustomerCancel"];
            this.email = _data["email"];
            if (Array.isArray(_data["dispatchRouteStatus"])) {
                this.dispatchRouteStatus = [] as any;
                for (let item of _data["dispatchRouteStatus"])
                    this.dispatchRouteStatus.push(DispatchRouteStatus.fromJS(item));
            }
            this.bookedByPartner = _data["bookedByPartner"];
            this.wantCashCollection = _data["wantCashCollection"];
            this.cashCollectionAmount = _data["cashCollectionAmount"];
            this.cashCollectionAccountNumber = _data["cashCollectionAccountNumber"];
            this.dispatchedAt = _data["dispatchedAt"] ? moment(_data["dispatchedAt"].toString()) : <any>undefined;
            this.deliveredAt = _data["deliveredAt"] ? moment(_data["deliveredAt"].toString()) : <any>undefined;
            this.createdFromEndpoint = _data["createdFromEndpoint"];
            this.personalizedLocalRateId = _data["personalizedLocalRateId"];
            this.personalizedLocalRate = _data["personalizedLocalRate"] ? PersonalizedLocalRate.fromJS(_data["personalizedLocalRate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LocalBooking {
        data = typeof data === 'object' ? data : {};
        let result = new LocalBooking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["deliveryType"] = this.deliveryType ? this.deliveryType.toJSON() : <any>undefined;
        data["paymentTypeId"] = this.paymentTypeId;
        data["bookingStatusId"] = this.bookingStatusId;
        data["isAccepted"] = this.isAccepted;
        data["isRejected"] = this.isRejected;
        data["isDispatched"] = this.isDispatched;
        data["isDelivered"] = this.isDelivered;
        data["isPaid"] = this.isPaid;
        data["bookingNumber"] = this.bookingNumber;
        data["bookingStatus"] = this.bookingStatus ? this.bookingStatus.toJSON() : <any>undefined;
        data["paymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        data["acceptanceNote"] = this.acceptanceNote;
        data["dispatchNote"] = this.dispatchNote;
        data["rejectionNote"] = this.rejectionNote;
        data["dispatcherId"] = this.dispatcherId;
        data["dispatcher"] = this.dispatcher ? this.dispatcher.toJSON() : <any>undefined;
        data["localRouteRateId"] = this.localRouteRateId;
        data["localRouteRate"] = this.localRouteRate ? this.localRouteRate.toJSON() : <any>undefined;
        data["senderName"] = this.senderName;
        data["pickUpAddress"] = this.pickUpAddress;
        data["pickupLandmark"] = this.pickupLandmark;
        data["phoneNumber"] = this.phoneNumber;
        data["actorPhoneNumber"] = this.actorPhoneNumber;
        data["recipientName"] = this.recipientName;
        data["deliveryAddress"] = this.deliveryAddress;
        data["deliveryLandmark"] = this.deliveryLandmark;
        data["recipientPhoneNumber"] = this.recipientPhoneNumber;
        data["pickupLocationId"] = this.pickupLocationId;
        data["deliveryLocationId"] = this.deliveryLocationId;
        data["pickupLocation"] = this.pickupLocation ? this.pickupLocation.toJSON() : <any>undefined;
        data["deliveryLocation"] = this.deliveryLocation ? this.deliveryLocation.toJSON() : <any>undefined;
        data["packageDescription"] = this.packageDescription;
        data["sizeDescription"] = this.sizeDescription;
        data["isInsured"] = this.isInsured;
        data["packageValue"] = this.packageValue;
        data["deliveryCost"] = this.deliveryCost;
        data["numberOfPackages"] = this.numberOfPackages;
        data["insuranceCost"] = this.insuranceCost;
        data["totalCost"] = this.totalCost;
        data["localBookingCategoryId"] = this.localBookingCategoryId;
        data["localBookingCategory"] = this.localBookingCategory ? this.localBookingCategory.toJSON() : <any>undefined;
        data["estimatedPackageWeight"] = this.estimatedPackageWeight;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["customerActorStateId"] = this.customerActorStateId;
        data["bulkOrderId"] = this.bulkOrderId;
        data["customerActorState"] = this.customerActorState ? this.customerActorState.toJSON() : <any>undefined;
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        data["bulkOrder"] = this.bulkOrder ? this.bulkOrder.toJSON() : <any>undefined;
        data["enableCustomerCancel"] = this.enableCustomerCancel;
        data["email"] = this.email;
        if (Array.isArray(this.dispatchRouteStatus)) {
            data["dispatchRouteStatus"] = [];
            for (let item of this.dispatchRouteStatus)
                data["dispatchRouteStatus"].push(item.toJSON());
        }
        data["bookedByPartner"] = this.bookedByPartner;
        data["wantCashCollection"] = this.wantCashCollection;
        data["cashCollectionAmount"] = this.cashCollectionAmount;
        data["cashCollectionAccountNumber"] = this.cashCollectionAccountNumber;
        data["dispatchedAt"] = this.dispatchedAt ? this.dispatchedAt.toISOString() : <any>undefined;
        data["deliveredAt"] = this.deliveredAt ? this.deliveredAt.toISOString() : <any>undefined;
        data["createdFromEndpoint"] = this.createdFromEndpoint;
        data["personalizedLocalRateId"] = this.personalizedLocalRateId;
        data["personalizedLocalRate"] = this.personalizedLocalRate ? this.personalizedLocalRate.toJSON() : <any>undefined;
        return data; 
    }

    clone(): LocalBooking {
        const json = this.toJSON();
        let result = new LocalBooking();
        result.init(json);
        return result;
    }
}

export interface ILocalBooking {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    deliveryDate: moment.Moment;
    deliveryTypeId: number | undefined;
    deliveryType: DeliveryType | undefined;
    paymentTypeId: number;
    bookingStatusId: number | undefined;
    isAccepted: boolean | undefined;
    isRejected: boolean | undefined;
    isDispatched: boolean | undefined;
    isDelivered: boolean | undefined;
    isPaid: boolean | undefined;
    bookingNumber: string | undefined;
    bookingStatus: BookingStatus | undefined;
    paymentType: PaymentType | undefined;
    acceptanceNote: string | undefined;
    dispatchNote: string | undefined;
    rejectionNote: string | undefined;
    dispatcherId: number | undefined;
    dispatcher: Dispatcher | undefined;
    localRouteRateId: number | undefined;
    localRouteRate: LocalRouteRate | undefined;
    senderName: string;
    pickUpAddress: string;
    pickupLandmark: string | undefined;
    phoneNumber: string;
    actorPhoneNumber: string | undefined;
    recipientName: string;
    deliveryAddress: string;
    deliveryLandmark: string | undefined;
    recipientPhoneNumber: string;
    pickupLocationId: number | undefined;
    deliveryLocationId: number | undefined;
    pickupLocation: Location | undefined;
    deliveryLocation: Location | undefined;
    packageDescription: string | undefined;
    sizeDescription: string | undefined;
    isInsured: boolean | undefined;
    packageValue: number | undefined;
    deliveryCost: number | undefined;
    numberOfPackages: number | undefined;
    insuranceCost: number | undefined;
    totalCost: number | undefined;
    localBookingCategoryId: number | undefined;
    localBookingCategory: LocalBookingCategory | undefined;
    estimatedPackageWeight: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    deletedAt: moment.Moment | undefined;
    customerActorStateId: number | undefined;
    bulkOrderId: number | undefined;
    customerActorState: CustomerActorState | undefined;
    payments: Payment[] | undefined;
    bulkOrder: BulkOrder | undefined;
    enableCustomerCancel: boolean | undefined;
    email: string | undefined;
    dispatchRouteStatus: DispatchRouteStatus[] | undefined;
    bookedByPartner: boolean | undefined;
    wantCashCollection: boolean | undefined;
    cashCollectionAmount: number | undefined;
    cashCollectionAccountNumber: string | undefined;
    dispatchedAt: moment.Moment | undefined;
    deliveredAt: moment.Moment | undefined;
    createdFromEndpoint: boolean | undefined;
    personalizedLocalRateId: number | undefined;
    personalizedLocalRate: PersonalizedLocalRate | undefined;
}

export class CustomizedLocationGroup implements ICustomizedLocationGroup {
    id: number | undefined;
    description: string | undefined;
    name: string | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    locations: Location[] | undefined;

    constructor(data?: ICustomizedLocationGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["locations"])) {
                this.locations = [] as any;
                for (let item of _data["locations"])
                    this.locations.push(Location.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomizedLocationGroup {
        data = typeof data === 'object' ? data : {};
        let result = new CustomizedLocationGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.locations)) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CustomizedLocationGroup {
        const json = this.toJSON();
        let result = new CustomizedLocationGroup();
        result.init(json);
        return result;
    }
}

export interface ICustomizedLocationGroup {
    id: number | undefined;
    description: string | undefined;
    name: string | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    locations: Location[] | undefined;
}

export class PaymentGateway implements IPaymentGateway {
    id: number | undefined;
    gatewayKey: string | undefined;
    active: boolean | undefined;
    controller: string | undefined;
    currencies: string | undefined;
    paymentGatewayConfigs: PaymentGatewayConfig[] | undefined;

    constructor(data?: IPaymentGateway) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.gatewayKey = _data["gatewayKey"];
            this.active = _data["active"];
            this.controller = _data["controller"];
            this.currencies = _data["currencies"];
            if (Array.isArray(_data["paymentGatewayConfigs"])) {
                this.paymentGatewayConfigs = [] as any;
                for (let item of _data["paymentGatewayConfigs"])
                    this.paymentGatewayConfigs.push(PaymentGatewayConfig.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentGateway {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGateway();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gatewayKey"] = this.gatewayKey;
        data["active"] = this.active;
        data["controller"] = this.controller;
        data["currencies"] = this.currencies;
        if (Array.isArray(this.paymentGatewayConfigs)) {
            data["paymentGatewayConfigs"] = [];
            for (let item of this.paymentGatewayConfigs)
                data["paymentGatewayConfigs"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PaymentGateway {
        const json = this.toJSON();
        let result = new PaymentGateway();
        result.init(json);
        return result;
    }
}

export interface IPaymentGateway {
    id: number | undefined;
    gatewayKey: string | undefined;
    active: boolean | undefined;
    controller: string | undefined;
    currencies: string | undefined;
    paymentGatewayConfigs: PaymentGatewayConfig[] | undefined;
}

export class PaymentStatus implements IPaymentStatus {
    id: number | undefined;
    name: string | undefined;
    payments: Payment[] | undefined;

    constructor(data?: IPaymentStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments.push(Payment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PaymentStatus {
        const json = this.toJSON();
        let result = new PaymentStatus();
        result.init(json);
        return result;
    }
}

export interface IPaymentStatus {
    id: number | undefined;
    name: string | undefined;
    payments: Payment[] | undefined;
}

export class LocalRouteRate implements ILocalRouteRate {
    id: number | undefined;
    fromLocationRatesGroupId: number | undefined;
    toLocationRatesGroupId: number | undefined;
    deliveryTypeId: number;
    generalRate: number;
    partnerRate: number;
    scale: number | undefined;
    chargeOnExtra: number | undefined;
    fromLocationId: number | undefined;
    fromLocation: Location | undefined;
    toLocationId: number | undefined;
    toLocation: Location | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    fromLocationRatesGroup: LocationRatesGroup | undefined;
    toLocationRatesGroup: LocationRatesGroup | undefined;
    deliveryType: DeliveryType | undefined;
    usesGroup: boolean | undefined;
    localBookings: LocalBooking[] | undefined;

    constructor(data?: ILocalRouteRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromLocationRatesGroupId = _data["fromLocationRatesGroupId"];
            this.toLocationRatesGroupId = _data["toLocationRatesGroupId"];
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.generalRate = _data["generalRate"];
            this.partnerRate = _data["partnerRate"];
            this.scale = _data["scale"];
            this.chargeOnExtra = _data["chargeOnExtra"];
            this.fromLocationId = _data["fromLocationId"];
            this.fromLocation = _data["fromLocation"] ? Location.fromJS(_data["fromLocation"]) : <any>undefined;
            this.toLocationId = _data["toLocationId"];
            this.toLocation = _data["toLocation"] ? Location.fromJS(_data["toLocation"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.fromLocationRatesGroup = _data["fromLocationRatesGroup"] ? LocationRatesGroup.fromJS(_data["fromLocationRatesGroup"]) : <any>undefined;
            this.toLocationRatesGroup = _data["toLocationRatesGroup"] ? LocationRatesGroup.fromJS(_data["toLocationRatesGroup"]) : <any>undefined;
            this.deliveryType = _data["deliveryType"] ? DeliveryType.fromJS(_data["deliveryType"]) : <any>undefined;
            this.usesGroup = _data["usesGroup"];
            if (Array.isArray(_data["localBookings"])) {
                this.localBookings = [] as any;
                for (let item of _data["localBookings"])
                    this.localBookings.push(LocalBooking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalRouteRate {
        data = typeof data === 'object' ? data : {};
        let result = new LocalRouteRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromLocationRatesGroupId"] = this.fromLocationRatesGroupId;
        data["toLocationRatesGroupId"] = this.toLocationRatesGroupId;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["generalRate"] = this.generalRate;
        data["partnerRate"] = this.partnerRate;
        data["scale"] = this.scale;
        data["chargeOnExtra"] = this.chargeOnExtra;
        data["fromLocationId"] = this.fromLocationId;
        data["fromLocation"] = this.fromLocation ? this.fromLocation.toJSON() : <any>undefined;
        data["toLocationId"] = this.toLocationId;
        data["toLocation"] = this.toLocation ? this.toLocation.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["fromLocationRatesGroup"] = this.fromLocationRatesGroup ? this.fromLocationRatesGroup.toJSON() : <any>undefined;
        data["toLocationRatesGroup"] = this.toLocationRatesGroup ? this.toLocationRatesGroup.toJSON() : <any>undefined;
        data["deliveryType"] = this.deliveryType ? this.deliveryType.toJSON() : <any>undefined;
        data["usesGroup"] = this.usesGroup;
        if (Array.isArray(this.localBookings)) {
            data["localBookings"] = [];
            for (let item of this.localBookings)
                data["localBookings"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocalRouteRate {
        const json = this.toJSON();
        let result = new LocalRouteRate();
        result.init(json);
        return result;
    }
}

export interface ILocalRouteRate {
    id: number | undefined;
    fromLocationRatesGroupId: number | undefined;
    toLocationRatesGroupId: number | undefined;
    deliveryTypeId: number;
    generalRate: number;
    partnerRate: number;
    scale: number | undefined;
    chargeOnExtra: number | undefined;
    fromLocationId: number | undefined;
    fromLocation: Location | undefined;
    toLocationId: number | undefined;
    toLocation: Location | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    fromLocationRatesGroup: LocationRatesGroup | undefined;
    toLocationRatesGroup: LocationRatesGroup | undefined;
    deliveryType: DeliveryType | undefined;
    usesGroup: boolean | undefined;
    localBookings: LocalBooking[] | undefined;
}

export class LocalBookingCategoryGroup implements ILocalBookingCategoryGroup {
    id: number | undefined;
    name: string;
    localBookingCategoryId: number | undefined;
    localBookingCategory: LocalBookingCategory | undefined;
    locationRatesGroups: LocationRatesGroup[] | undefined;
    toggleBookingActivation: boolean | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;

    constructor(data?: ILocalBookingCategoryGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.localBookingCategoryId = _data["localBookingCategoryId"];
            this.localBookingCategory = _data["localBookingCategory"] ? LocalBookingCategory.fromJS(_data["localBookingCategory"]) : <any>undefined;
            if (Array.isArray(_data["locationRatesGroups"])) {
                this.locationRatesGroups = [] as any;
                for (let item of _data["locationRatesGroups"])
                    this.locationRatesGroups.push(LocationRatesGroup.fromJS(item));
            }
            this.toggleBookingActivation = _data["toggleBookingActivation"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LocalBookingCategoryGroup {
        data = typeof data === 'object' ? data : {};
        let result = new LocalBookingCategoryGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["localBookingCategoryId"] = this.localBookingCategoryId;
        data["localBookingCategory"] = this.localBookingCategory ? this.localBookingCategory.toJSON() : <any>undefined;
        if (Array.isArray(this.locationRatesGroups)) {
            data["locationRatesGroups"] = [];
            for (let item of this.locationRatesGroups)
                data["locationRatesGroups"].push(item.toJSON());
        }
        data["toggleBookingActivation"] = this.toggleBookingActivation;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }

    clone(): LocalBookingCategoryGroup {
        const json = this.toJSON();
        let result = new LocalBookingCategoryGroup();
        result.init(json);
        return result;
    }
}

export interface ILocalBookingCategoryGroup {
    id: number | undefined;
    name: string;
    localBookingCategoryId: number | undefined;
    localBookingCategory: LocalBookingCategory | undefined;
    locationRatesGroups: LocationRatesGroup[] | undefined;
    toggleBookingActivation: boolean | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
}

export class DeliveryType implements IDeliveryType {
    id: number | undefined;
    name: string;
    toggleBookingActivation: boolean | undefined;
    isActive: boolean | undefined;
    localRouteRates: LocalRouteRate[] | undefined;
    localBookings: LocalBooking[] | undefined;

    constructor(data?: IDeliveryType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.toggleBookingActivation = _data["toggleBookingActivation"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["localRouteRates"])) {
                this.localRouteRates = [] as any;
                for (let item of _data["localRouteRates"])
                    this.localRouteRates.push(LocalRouteRate.fromJS(item));
            }
            if (Array.isArray(_data["localBookings"])) {
                this.localBookings = [] as any;
                for (let item of _data["localBookings"])
                    this.localBookings.push(LocalBooking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeliveryType {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["toggleBookingActivation"] = this.toggleBookingActivation;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.localRouteRates)) {
            data["localRouteRates"] = [];
            for (let item of this.localRouteRates)
                data["localRouteRates"].push(item.toJSON());
        }
        if (Array.isArray(this.localBookings)) {
            data["localBookings"] = [];
            for (let item of this.localBookings)
                data["localBookings"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DeliveryType {
        const json = this.toJSON();
        let result = new DeliveryType();
        result.init(json);
        return result;
    }
}

export interface IDeliveryType {
    id: number | undefined;
    name: string;
    toggleBookingActivation: boolean | undefined;
    isActive: boolean | undefined;
    localRouteRates: LocalRouteRate[] | undefined;
    localBookings: LocalBooking[] | undefined;
}

export class BookingStatus implements IBookingStatus {
    id: number | undefined;
    name: string | undefined;
    localBookings: LocalBooking[] | undefined;

    constructor(data?: IBookingStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["localBookings"])) {
                this.localBookings = [] as any;
                for (let item of _data["localBookings"])
                    this.localBookings.push(LocalBooking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BookingStatus {
        data = typeof data === 'object' ? data : {};
        let result = new BookingStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.localBookings)) {
            data["localBookings"] = [];
            for (let item of this.localBookings)
                data["localBookings"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BookingStatus {
        const json = this.toJSON();
        let result = new BookingStatus();
        result.init(json);
        return result;
    }
}

export interface IBookingStatus {
    id: number | undefined;
    name: string | undefined;
    localBookings: LocalBooking[] | undefined;
}

export class PaymentType implements IPaymentType {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    localBookings: LocalBooking[] | undefined;

    constructor(data?: IPaymentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["localBookings"])) {
                this.localBookings = [] as any;
                for (let item of _data["localBookings"])
                    this.localBookings.push(LocalBooking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentType {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.localBookings)) {
            data["localBookings"] = [];
            for (let item of this.localBookings)
                data["localBookings"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PaymentType {
        const json = this.toJSON();
        let result = new PaymentType();
        result.init(json);
        return result;
    }
}

export interface IPaymentType {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
    localBookings: LocalBooking[] | undefined;
}

export class Dispatcher implements IDispatcher {
    id: number | undefined;
    name: string;
    dispatcherStatusesId: number | undefined;
    userId: string | undefined;
    aspNetUser: AspNetUser | undefined;
    phoneNumber: string;
    sponsorName: string;
    sponsorAddress: string;
    sponsorPhoneNumber: string | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    dispatcherStatus: DispatcherStatus | undefined;
    localBookings: LocalBooking[] | undefined;
    tokenVerified: boolean | undefined;
    appToken: string | undefined;
    tokenCreatedAt: moment.Moment | undefined;
    tokenVerifiedAt: moment.Moment | undefined;
    appLastActivity: moment.Moment | undefined;
    verificationCode: string | undefined;
    verificationCodeCreatedAt: moment.Moment | undefined;
    fcmToken: string | undefined;
    trackingUsername: string | undefined;
    trackingPassword: string | undefined;

    constructor(data?: IDispatcher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dispatcherStatusesId = _data["dispatcherStatusesId"];
            this.userId = _data["userId"];
            this.aspNetUser = _data["aspNetUser"] ? AspNetUser.fromJS(_data["aspNetUser"]) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.sponsorName = _data["sponsorName"];
            this.sponsorAddress = _data["sponsorAddress"];
            this.sponsorPhoneNumber = _data["sponsorPhoneNumber"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.dispatcherStatus = _data["dispatcherStatus"] ? DispatcherStatus.fromJS(_data["dispatcherStatus"]) : <any>undefined;
            if (Array.isArray(_data["localBookings"])) {
                this.localBookings = [] as any;
                for (let item of _data["localBookings"])
                    this.localBookings.push(LocalBooking.fromJS(item));
            }
            this.tokenVerified = _data["tokenVerified"];
            this.appToken = _data["appToken"];
            this.tokenCreatedAt = _data["tokenCreatedAt"] ? moment(_data["tokenCreatedAt"].toString()) : <any>undefined;
            this.tokenVerifiedAt = _data["tokenVerifiedAt"] ? moment(_data["tokenVerifiedAt"].toString()) : <any>undefined;
            this.appLastActivity = _data["appLastActivity"] ? moment(_data["appLastActivity"].toString()) : <any>undefined;
            this.verificationCode = _data["verificationCode"];
            this.verificationCodeCreatedAt = _data["verificationCodeCreatedAt"] ? moment(_data["verificationCodeCreatedAt"].toString()) : <any>undefined;
            this.fcmToken = _data["fcmToken"];
            this.trackingUsername = _data["trackingUsername"];
            this.trackingPassword = _data["trackingPassword"];
        }
    }

    static fromJS(data: any): Dispatcher {
        data = typeof data === 'object' ? data : {};
        let result = new Dispatcher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dispatcherStatusesId"] = this.dispatcherStatusesId;
        data["userId"] = this.userId;
        data["aspNetUser"] = this.aspNetUser ? this.aspNetUser.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["sponsorName"] = this.sponsorName;
        data["sponsorAddress"] = this.sponsorAddress;
        data["sponsorPhoneNumber"] = this.sponsorPhoneNumber;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["dispatcherStatus"] = this.dispatcherStatus ? this.dispatcherStatus.toJSON() : <any>undefined;
        if (Array.isArray(this.localBookings)) {
            data["localBookings"] = [];
            for (let item of this.localBookings)
                data["localBookings"].push(item.toJSON());
        }
        data["tokenVerified"] = this.tokenVerified;
        data["appToken"] = this.appToken;
        data["tokenCreatedAt"] = this.tokenCreatedAt ? this.tokenCreatedAt.toISOString() : <any>undefined;
        data["tokenVerifiedAt"] = this.tokenVerifiedAt ? this.tokenVerifiedAt.toISOString() : <any>undefined;
        data["appLastActivity"] = this.appLastActivity ? this.appLastActivity.toISOString() : <any>undefined;
        data["verificationCode"] = this.verificationCode;
        data["verificationCodeCreatedAt"] = this.verificationCodeCreatedAt ? this.verificationCodeCreatedAt.toISOString() : <any>undefined;
        data["fcmToken"] = this.fcmToken;
        data["trackingUsername"] = this.trackingUsername;
        data["trackingPassword"] = this.trackingPassword;
        return data; 
    }

    clone(): Dispatcher {
        const json = this.toJSON();
        let result = new Dispatcher();
        result.init(json);
        return result;
    }
}

export interface IDispatcher {
    id: number | undefined;
    name: string;
    dispatcherStatusesId: number | undefined;
    userId: string | undefined;
    aspNetUser: AspNetUser | undefined;
    phoneNumber: string;
    sponsorName: string;
    sponsorAddress: string;
    sponsorPhoneNumber: string | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    dispatcherStatus: DispatcherStatus | undefined;
    localBookings: LocalBooking[] | undefined;
    tokenVerified: boolean | undefined;
    appToken: string | undefined;
    tokenCreatedAt: moment.Moment | undefined;
    tokenVerifiedAt: moment.Moment | undefined;
    appLastActivity: moment.Moment | undefined;
    verificationCode: string | undefined;
    verificationCodeCreatedAt: moment.Moment | undefined;
    fcmToken: string | undefined;
    trackingUsername: string | undefined;
    trackingPassword: string | undefined;
}

export class CustomerActorState implements ICustomerActorState {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: ICustomerActorState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CustomerActorState {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerActorState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): CustomerActorState {
        const json = this.toJSON();
        let result = new CustomerActorState();
        result.init(json);
        return result;
    }
}

export interface ICustomerActorState {
    id: number | undefined;
    name: string | undefined;
}

export class Payment implements IPayment {
    id: number | undefined;
    paymentGatewayId: number | undefined;
    orderType: string | undefined;
    userId: string | undefined;
    transactionId: string | undefined;
    transactionReference: string | undefined;
    totalAmount: number | undefined;
    currency: string | undefined;
    paymentStatusId: number | undefined;
    localBookingId: number | undefined;
    checkoutAssistanceId: number | undefined;
    internationalBookingId: number | undefined;
    invoiceId: number | undefined;
    isUsed: boolean | undefined;
    paymentGateway: PaymentGateway | undefined;
    aspNetUser: Customer | undefined;
    paymentStatus: PaymentStatus | undefined;
    localBooking: LocalBooking | undefined;
    internationalBooking: InternationalBooking | undefined;
    checkoutAssistance: CheckoutAssistance | undefined;
    invoice: Invoice | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentGatewayId = _data["paymentGatewayId"];
            this.orderType = _data["orderType"];
            this.userId = _data["userId"];
            this.transactionId = _data["transactionId"];
            this.transactionReference = _data["transactionReference"];
            this.totalAmount = _data["totalAmount"];
            this.currency = _data["currency"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.localBookingId = _data["localBookingId"];
            this.checkoutAssistanceId = _data["checkoutAssistanceId"];
            this.internationalBookingId = _data["internationalBookingId"];
            this.invoiceId = _data["invoiceId"];
            this.isUsed = _data["isUsed"];
            this.paymentGateway = _data["paymentGateway"] ? PaymentGateway.fromJS(_data["paymentGateway"]) : <any>undefined;
            this.aspNetUser = _data["aspNetUser"] ? Customer.fromJS(_data["aspNetUser"]) : <any>undefined;
            this.paymentStatus = _data["paymentStatus"] ? PaymentStatus.fromJS(_data["paymentStatus"]) : <any>undefined;
            this.localBooking = _data["localBooking"] ? LocalBooking.fromJS(_data["localBooking"]) : <any>undefined;
            this.internationalBooking = _data["internationalBooking"] ? InternationalBooking.fromJS(_data["internationalBooking"]) : <any>undefined;
            this.checkoutAssistance = _data["checkoutAssistance"] ? CheckoutAssistance.fromJS(_data["checkoutAssistance"]) : <any>undefined;
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentGatewayId"] = this.paymentGatewayId;
        data["orderType"] = this.orderType;
        data["userId"] = this.userId;
        data["transactionId"] = this.transactionId;
        data["transactionReference"] = this.transactionReference;
        data["totalAmount"] = this.totalAmount;
        data["currency"] = this.currency;
        data["paymentStatusId"] = this.paymentStatusId;
        data["localBookingId"] = this.localBookingId;
        data["checkoutAssistanceId"] = this.checkoutAssistanceId;
        data["internationalBookingId"] = this.internationalBookingId;
        data["invoiceId"] = this.invoiceId;
        data["isUsed"] = this.isUsed;
        data["paymentGateway"] = this.paymentGateway ? this.paymentGateway.toJSON() : <any>undefined;
        data["aspNetUser"] = this.aspNetUser ? this.aspNetUser.toJSON() : <any>undefined;
        data["paymentStatus"] = this.paymentStatus ? this.paymentStatus.toJSON() : <any>undefined;
        data["localBooking"] = this.localBooking ? this.localBooking.toJSON() : <any>undefined;
        data["internationalBooking"] = this.internationalBooking ? this.internationalBooking.toJSON() : <any>undefined;
        data["checkoutAssistance"] = this.checkoutAssistance ? this.checkoutAssistance.toJSON() : <any>undefined;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }

    clone(): Payment {
        const json = this.toJSON();
        let result = new Payment();
        result.init(json);
        return result;
    }
}

export interface IPayment {
    id: number | undefined;
    paymentGatewayId: number | undefined;
    orderType: string | undefined;
    userId: string | undefined;
    transactionId: string | undefined;
    transactionReference: string | undefined;
    totalAmount: number | undefined;
    currency: string | undefined;
    paymentStatusId: number | undefined;
    localBookingId: number | undefined;
    checkoutAssistanceId: number | undefined;
    internationalBookingId: number | undefined;
    invoiceId: number | undefined;
    isUsed: boolean | undefined;
    paymentGateway: PaymentGateway | undefined;
    aspNetUser: Customer | undefined;
    paymentStatus: PaymentStatus | undefined;
    localBooking: LocalBooking | undefined;
    internationalBooking: InternationalBooking | undefined;
    checkoutAssistance: CheckoutAssistance | undefined;
    invoice: Invoice | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
}

export class BulkOrder implements IBulkOrder {
    id: number | undefined;
    userId: string | undefined;
    totalCost: number | undefined;
    cancelledBy: string | undefined;
    enableCustomerCancel: boolean | undefined;
    isPaid: boolean | undefined;
    bookingStatusesId: number | undefined;
    bookingStatus: BookingStatus | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    cancelledAt: moment.Moment | undefined;
    customer: Customer | undefined;
    localBookings: LocalBooking[] | undefined;
    paymentTypeId: number | undefined;
    paymentType: PaymentType | undefined;

    constructor(data?: IBulkOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.totalCost = _data["totalCost"];
            this.cancelledBy = _data["cancelledBy"];
            this.enableCustomerCancel = _data["enableCustomerCancel"];
            this.isPaid = _data["isPaid"];
            this.bookingStatusesId = _data["bookingStatusesId"];
            this.bookingStatus = _data["bookingStatus"] ? BookingStatus.fromJS(_data["bookingStatus"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.cancelledAt = _data["cancelledAt"] ? moment(_data["cancelledAt"].toString()) : <any>undefined;
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            if (Array.isArray(_data["localBookings"])) {
                this.localBookings = [] as any;
                for (let item of _data["localBookings"])
                    this.localBookings.push(LocalBooking.fromJS(item));
            }
            this.paymentTypeId = _data["paymentTypeId"];
            this.paymentType = _data["paymentType"] ? PaymentType.fromJS(_data["paymentType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BulkOrder {
        data = typeof data === 'object' ? data : {};
        let result = new BulkOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["totalCost"] = this.totalCost;
        data["cancelledBy"] = this.cancelledBy;
        data["enableCustomerCancel"] = this.enableCustomerCancel;
        data["isPaid"] = this.isPaid;
        data["bookingStatusesId"] = this.bookingStatusesId;
        data["bookingStatus"] = this.bookingStatus ? this.bookingStatus.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["cancelledAt"] = this.cancelledAt ? this.cancelledAt.toISOString() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.localBookings)) {
            data["localBookings"] = [];
            for (let item of this.localBookings)
                data["localBookings"].push(item.toJSON());
        }
        data["paymentTypeId"] = this.paymentTypeId;
        data["paymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BulkOrder {
        const json = this.toJSON();
        let result = new BulkOrder();
        result.init(json);
        return result;
    }
}

export interface IBulkOrder {
    id: number | undefined;
    userId: string | undefined;
    totalCost: number | undefined;
    cancelledBy: string | undefined;
    enableCustomerCancel: boolean | undefined;
    isPaid: boolean | undefined;
    bookingStatusesId: number | undefined;
    bookingStatus: BookingStatus | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    cancelledAt: moment.Moment | undefined;
    customer: Customer | undefined;
    localBookings: LocalBooking[] | undefined;
    paymentTypeId: number | undefined;
    paymentType: PaymentType | undefined;
}

export class DispatchRouteStatus implements IDispatchRouteStatus {
    id: number | undefined;
    localBookingId: number | undefined;
    dispatcherId: number | undefined;
    comment: string | undefined;
    isDispatched: boolean | undefined;
    isReRouted: boolean | undefined;
    isDelivered: boolean | undefined;
    createdAt: moment.Moment | undefined;
    localBooking: LocalBooking | undefined;
    dispatcher: Dispatcher | undefined;

    constructor(data?: IDispatchRouteStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localBookingId = _data["localBookingId"];
            this.dispatcherId = _data["dispatcherId"];
            this.comment = _data["comment"];
            this.isDispatched = _data["isDispatched"];
            this.isReRouted = _data["isReRouted"];
            this.isDelivered = _data["isDelivered"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.localBooking = _data["localBooking"] ? LocalBooking.fromJS(_data["localBooking"]) : <any>undefined;
            this.dispatcher = _data["dispatcher"] ? Dispatcher.fromJS(_data["dispatcher"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DispatchRouteStatus {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchRouteStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localBookingId"] = this.localBookingId;
        data["dispatcherId"] = this.dispatcherId;
        data["comment"] = this.comment;
        data["isDispatched"] = this.isDispatched;
        data["isReRouted"] = this.isReRouted;
        data["isDelivered"] = this.isDelivered;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["localBooking"] = this.localBooking ? this.localBooking.toJSON() : <any>undefined;
        data["dispatcher"] = this.dispatcher ? this.dispatcher.toJSON() : <any>undefined;
        return data; 
    }

    clone(): DispatchRouteStatus {
        const json = this.toJSON();
        let result = new DispatchRouteStatus();
        result.init(json);
        return result;
    }
}

export interface IDispatchRouteStatus {
    id: number | undefined;
    localBookingId: number | undefined;
    dispatcherId: number | undefined;
    comment: string | undefined;
    isDispatched: boolean | undefined;
    isReRouted: boolean | undefined;
    isDelivered: boolean | undefined;
    createdAt: moment.Moment | undefined;
    localBooking: LocalBooking | undefined;
    dispatcher: Dispatcher | undefined;
}

export class PersonalizedLocalRate implements IPersonalizedLocalRate {
    id: number | undefined;
    flatRate: number;
    isActive: boolean | undefined;
    enableScale: boolean | undefined;
    scale: number | undefined;
    chargeOnExtra: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    userId: string;
    customer: Customer | undefined;
    localBookingCategoryId: number | undefined;
    localBookingCategory: LocalBookingCategory | undefined;

    constructor(data?: IPersonalizedLocalRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flatRate = _data["flatRate"];
            this.isActive = _data["isActive"];
            this.enableScale = _data["enableScale"];
            this.scale = _data["scale"];
            this.chargeOnExtra = _data["chargeOnExtra"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.localBookingCategoryId = _data["localBookingCategoryId"];
            this.localBookingCategory = _data["localBookingCategory"] ? LocalBookingCategory.fromJS(_data["localBookingCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PersonalizedLocalRate {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalizedLocalRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flatRate"] = this.flatRate;
        data["isActive"] = this.isActive;
        data["enableScale"] = this.enableScale;
        data["scale"] = this.scale;
        data["chargeOnExtra"] = this.chargeOnExtra;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["localBookingCategoryId"] = this.localBookingCategoryId;
        data["localBookingCategory"] = this.localBookingCategory ? this.localBookingCategory.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PersonalizedLocalRate {
        const json = this.toJSON();
        let result = new PersonalizedLocalRate();
        result.init(json);
        return result;
    }
}

export interface IPersonalizedLocalRate {
    id: number | undefined;
    flatRate: number;
    isActive: boolean | undefined;
    enableScale: boolean | undefined;
    scale: number | undefined;
    chargeOnExtra: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    userId: string;
    customer: Customer | undefined;
    localBookingCategoryId: number | undefined;
    localBookingCategory: LocalBookingCategory | undefined;
}

export class PaymentGatewayConfig implements IPaymentGatewayConfig {
    id: number | undefined;
    paymentGatewayId: number | undefined;
    name: string | undefined;
    value: string | undefined;
    paymentGateway: PaymentGateway | undefined;

    constructor(data?: IPaymentGatewayConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paymentGatewayId = _data["paymentGatewayId"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.paymentGateway = _data["paymentGateway"] ? PaymentGateway.fromJS(_data["paymentGateway"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentGatewayConfig {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paymentGatewayId"] = this.paymentGatewayId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["paymentGateway"] = this.paymentGateway ? this.paymentGateway.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PaymentGatewayConfig {
        const json = this.toJSON();
        let result = new PaymentGatewayConfig();
        result.init(json);
        return result;
    }
}

export interface IPaymentGatewayConfig {
    id: number | undefined;
    paymentGatewayId: number | undefined;
    name: string | undefined;
    value: string | undefined;
    paymentGateway: PaymentGateway | undefined;
}

export class DispatcherStatus implements IDispatcherStatus {
    id: number | undefined;
    name: string;
    dispatchers: Dispatcher[] | undefined;

    constructor(data?: IDispatcherStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["dispatchers"])) {
                this.dispatchers = [] as any;
                for (let item of _data["dispatchers"])
                    this.dispatchers.push(Dispatcher.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DispatcherStatus {
        data = typeof data === 'object' ? data : {};
        let result = new DispatcherStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.dispatchers)) {
            data["dispatchers"] = [];
            for (let item of this.dispatchers)
                data["dispatchers"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DispatcherStatus {
        const json = this.toJSON();
        let result = new DispatcherStatus();
        result.init(json);
        return result;
    }
}

export interface IDispatcherStatus {
    id: number | undefined;
    name: string;
    dispatchers: Dispatcher[] | undefined;
}

export class InternationalBooking implements IInternationalBooking {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    kindOfBooking: string | undefined;
    eta: moment.Moment | undefined;
    shipmentModeId: number | undefined;
    shipmentMode: ShipmentMode | undefined;
    shipmentDeliveryTypeId: number;
    shipmentDeliveryType: ShipmentDeliveryType | undefined;
    pickupContactName: string | undefined;
    pickupAddress: string | undefined;
    pickupContactPhone: string | undefined;
    country: string;
    isPaid: boolean | undefined;
    recipientName: string | undefined;
    deliveryAddress: string | undefined;
    recipientPhone: string | undefined;
    estimatedPackageWeight: number | undefined;
    actualPackageWeight: number | undefined;
    estimatedPackageSize: string | undefined;
    homeDelivery: boolean | undefined;
    homeDeliveryCharge: number | undefined;
    homeDeliveryLocationId: number | undefined;
    homeDeliveryLocation: Location | undefined;
    pickup: boolean | undefined;
    pickupCharge: number | undefined;
    pickupLocationId: number | undefined;
    pickupLocation: Location | undefined;
    shippingCost: number | undefined;
    exchangeRate: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    deletedAt: moment.Moment | undefined;
    bookingNumber: string | undefined;
    processNote: string | undefined;
    rejectionNote: string | undefined;
    hasHoldInstruction: boolean | undefined;
    holdInstruction: HoldInstruction | undefined;
    packageDescription: string;
    zipCode: number | undefined;
    postCode: number | undefined;
    localHomeDeliveryTypeId: number | undefined;
    localHomeDeliveryType: DeliveryType | undefined;
    carrier: string | undefined;
    trackingNumber: string | undefined;
    shippingBatchId: number | undefined;
    shippingBatch: ShippingBatch | undefined;
    receivedAt: moment.Moment | undefined;
    intlStatusTimeline: IntlStatusTimeline[] | undefined;
    bookingStatusId: number | undefined;
    bookingStatus: IntlBookingStatus | undefined;
    payments: Payment[] | undefined;
    initiatorId: string | undefined;
    packageValue: number | undefined;
    initiator: AspNetUser | undefined;

    constructor(data?: IInternationalBooking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.kindOfBooking = _data["kindOfBooking"];
            this.eta = _data["eta"] ? moment(_data["eta"].toString()) : <any>undefined;
            this.shipmentModeId = _data["shipmentModeId"];
            this.shipmentMode = _data["shipmentMode"] ? ShipmentMode.fromJS(_data["shipmentMode"]) : <any>undefined;
            this.shipmentDeliveryTypeId = _data["shipmentDeliveryTypeId"];
            this.shipmentDeliveryType = _data["shipmentDeliveryType"] ? ShipmentDeliveryType.fromJS(_data["shipmentDeliveryType"]) : <any>undefined;
            this.pickupContactName = _data["pickupContactName"];
            this.pickupAddress = _data["pickupAddress"];
            this.pickupContactPhone = _data["pickupContactPhone"];
            this.country = _data["country"];
            this.isPaid = _data["isPaid"];
            this.recipientName = _data["recipientName"];
            this.deliveryAddress = _data["deliveryAddress"];
            this.recipientPhone = _data["recipientPhone"];
            this.estimatedPackageWeight = _data["estimatedPackageWeight"];
            this.actualPackageWeight = _data["actualPackageWeight"];
            this.estimatedPackageSize = _data["estimatedPackageSize"];
            this.homeDelivery = _data["homeDelivery"];
            this.homeDeliveryCharge = _data["homeDeliveryCharge"];
            this.homeDeliveryLocationId = _data["homeDeliveryLocationId"];
            this.homeDeliveryLocation = _data["homeDeliveryLocation"] ? Location.fromJS(_data["homeDeliveryLocation"]) : <any>undefined;
            this.pickup = _data["pickup"];
            this.pickupCharge = _data["pickupCharge"];
            this.pickupLocationId = _data["pickupLocationId"];
            this.pickupLocation = _data["pickupLocation"] ? Location.fromJS(_data["pickupLocation"]) : <any>undefined;
            this.shippingCost = _data["shippingCost"];
            this.exchangeRate = _data["exchangeRate"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.bookingNumber = _data["bookingNumber"];
            this.processNote = _data["processNote"];
            this.rejectionNote = _data["rejectionNote"];
            this.hasHoldInstruction = _data["hasHoldInstruction"];
            this.holdInstruction = _data["holdInstruction"] ? HoldInstruction.fromJS(_data["holdInstruction"]) : <any>undefined;
            this.packageDescription = _data["packageDescription"];
            this.zipCode = _data["zipCode"];
            this.postCode = _data["postCode"];
            this.localHomeDeliveryTypeId = _data["localHomeDeliveryTypeId"];
            this.localHomeDeliveryType = _data["localHomeDeliveryType"] ? DeliveryType.fromJS(_data["localHomeDeliveryType"]) : <any>undefined;
            this.carrier = _data["carrier"];
            this.trackingNumber = _data["trackingNumber"];
            this.shippingBatchId = _data["shippingBatchId"];
            this.shippingBatch = _data["shippingBatch"] ? ShippingBatch.fromJS(_data["shippingBatch"]) : <any>undefined;
            this.receivedAt = _data["receivedAt"] ? moment(_data["receivedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["intlStatusTimeline"])) {
                this.intlStatusTimeline = [] as any;
                for (let item of _data["intlStatusTimeline"])
                    this.intlStatusTimeline.push(IntlStatusTimeline.fromJS(item));
            }
            this.bookingStatusId = _data["bookingStatusId"];
            this.bookingStatus = _data["bookingStatus"] ? IntlBookingStatus.fromJS(_data["bookingStatus"]) : <any>undefined;
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments.push(Payment.fromJS(item));
            }
            this.initiatorId = _data["initiatorId"];
            this.packageValue = _data["packageValue"];
            this.initiator = _data["initiator"] ? AspNetUser.fromJS(_data["initiator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InternationalBooking {
        data = typeof data === 'object' ? data : {};
        let result = new InternationalBooking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["kindOfBooking"] = this.kindOfBooking;
        data["eta"] = this.eta ? this.eta.toISOString() : <any>undefined;
        data["shipmentModeId"] = this.shipmentModeId;
        data["shipmentMode"] = this.shipmentMode ? this.shipmentMode.toJSON() : <any>undefined;
        data["shipmentDeliveryTypeId"] = this.shipmentDeliveryTypeId;
        data["shipmentDeliveryType"] = this.shipmentDeliveryType ? this.shipmentDeliveryType.toJSON() : <any>undefined;
        data["pickupContactName"] = this.pickupContactName;
        data["pickupAddress"] = this.pickupAddress;
        data["pickupContactPhone"] = this.pickupContactPhone;
        data["country"] = this.country;
        data["isPaid"] = this.isPaid;
        data["recipientName"] = this.recipientName;
        data["deliveryAddress"] = this.deliveryAddress;
        data["recipientPhone"] = this.recipientPhone;
        data["estimatedPackageWeight"] = this.estimatedPackageWeight;
        data["actualPackageWeight"] = this.actualPackageWeight;
        data["estimatedPackageSize"] = this.estimatedPackageSize;
        data["homeDelivery"] = this.homeDelivery;
        data["homeDeliveryCharge"] = this.homeDeliveryCharge;
        data["homeDeliveryLocationId"] = this.homeDeliveryLocationId;
        data["homeDeliveryLocation"] = this.homeDeliveryLocation ? this.homeDeliveryLocation.toJSON() : <any>undefined;
        data["pickup"] = this.pickup;
        data["pickupCharge"] = this.pickupCharge;
        data["pickupLocationId"] = this.pickupLocationId;
        data["pickupLocation"] = this.pickupLocation ? this.pickupLocation.toJSON() : <any>undefined;
        data["shippingCost"] = this.shippingCost;
        data["exchangeRate"] = this.exchangeRate;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["bookingNumber"] = this.bookingNumber;
        data["processNote"] = this.processNote;
        data["rejectionNote"] = this.rejectionNote;
        data["hasHoldInstruction"] = this.hasHoldInstruction;
        data["holdInstruction"] = this.holdInstruction ? this.holdInstruction.toJSON() : <any>undefined;
        data["packageDescription"] = this.packageDescription;
        data["zipCode"] = this.zipCode;
        data["postCode"] = this.postCode;
        data["localHomeDeliveryTypeId"] = this.localHomeDeliveryTypeId;
        data["localHomeDeliveryType"] = this.localHomeDeliveryType ? this.localHomeDeliveryType.toJSON() : <any>undefined;
        data["carrier"] = this.carrier;
        data["trackingNumber"] = this.trackingNumber;
        data["shippingBatchId"] = this.shippingBatchId;
        data["shippingBatch"] = this.shippingBatch ? this.shippingBatch.toJSON() : <any>undefined;
        data["receivedAt"] = this.receivedAt ? this.receivedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.intlStatusTimeline)) {
            data["intlStatusTimeline"] = [];
            for (let item of this.intlStatusTimeline)
                data["intlStatusTimeline"].push(item.toJSON());
        }
        data["bookingStatusId"] = this.bookingStatusId;
        data["bookingStatus"] = this.bookingStatus ? this.bookingStatus.toJSON() : <any>undefined;
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        data["initiatorId"] = this.initiatorId;
        data["packageValue"] = this.packageValue;
        data["initiator"] = this.initiator ? this.initiator.toJSON() : <any>undefined;
        return data; 
    }

    clone(): InternationalBooking {
        const json = this.toJSON();
        let result = new InternationalBooking();
        result.init(json);
        return result;
    }
}

export interface IInternationalBooking {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    kindOfBooking: string | undefined;
    eta: moment.Moment | undefined;
    shipmentModeId: number | undefined;
    shipmentMode: ShipmentMode | undefined;
    shipmentDeliveryTypeId: number;
    shipmentDeliveryType: ShipmentDeliveryType | undefined;
    pickupContactName: string | undefined;
    pickupAddress: string | undefined;
    pickupContactPhone: string | undefined;
    country: string;
    isPaid: boolean | undefined;
    recipientName: string | undefined;
    deliveryAddress: string | undefined;
    recipientPhone: string | undefined;
    estimatedPackageWeight: number | undefined;
    actualPackageWeight: number | undefined;
    estimatedPackageSize: string | undefined;
    homeDelivery: boolean | undefined;
    homeDeliveryCharge: number | undefined;
    homeDeliveryLocationId: number | undefined;
    homeDeliveryLocation: Location | undefined;
    pickup: boolean | undefined;
    pickupCharge: number | undefined;
    pickupLocationId: number | undefined;
    pickupLocation: Location | undefined;
    shippingCost: number | undefined;
    exchangeRate: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    deletedAt: moment.Moment | undefined;
    bookingNumber: string | undefined;
    processNote: string | undefined;
    rejectionNote: string | undefined;
    hasHoldInstruction: boolean | undefined;
    holdInstruction: HoldInstruction | undefined;
    packageDescription: string;
    zipCode: number | undefined;
    postCode: number | undefined;
    localHomeDeliveryTypeId: number | undefined;
    localHomeDeliveryType: DeliveryType | undefined;
    carrier: string | undefined;
    trackingNumber: string | undefined;
    shippingBatchId: number | undefined;
    shippingBatch: ShippingBatch | undefined;
    receivedAt: moment.Moment | undefined;
    intlStatusTimeline: IntlStatusTimeline[] | undefined;
    bookingStatusId: number | undefined;
    bookingStatus: IntlBookingStatus | undefined;
    payments: Payment[] | undefined;
    initiatorId: string | undefined;
    packageValue: number | undefined;
    initiator: AspNetUser | undefined;
}

export class CheckoutAssistance implements ICheckoutAssistance {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    customerName: string;
    customerPhone: string;
    customerAddress: string | undefined;
    checkoutProcessing: string | undefined;
    pickupCenter: string | undefined;
    shipToState: string | undefined;
    deliveryLocationId: number | undefined;
    deliveryLocation: Location | undefined;
    processNote: string | undefined;
    rejectionNote: string | undefined;
    isAccepted: boolean | undefined;
    isRejected: boolean | undefined;
    isPaid: boolean | undefined;
    bookingNumber: string | undefined;
    totalCost: number | undefined;
    bookingStatusId: number | undefined;
    shippingCostTax: number | undefined;
    trackingNumber: string | undefined;
    bookingStatus: IntlBookingStatus | undefined;
    receivedAt: moment.Moment | undefined;
    numberOfProcessedWebsites: number | undefined;
    checkoutAssistanceWebsites: CheckoutAssistanceWebsite[] | undefined;
    checkoutAssistanceStatus: CheckoutAssistanceStatus[] | undefined;
    payments: Payment[] | undefined;

    constructor(data?: ICheckoutAssistance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.customerName = _data["customerName"];
            this.customerPhone = _data["customerPhone"];
            this.customerAddress = _data["customerAddress"];
            this.checkoutProcessing = _data["checkoutProcessing"];
            this.pickupCenter = _data["pickupCenter"];
            this.shipToState = _data["shipToState"];
            this.deliveryLocationId = _data["deliveryLocationId"];
            this.deliveryLocation = _data["deliveryLocation"] ? Location.fromJS(_data["deliveryLocation"]) : <any>undefined;
            this.processNote = _data["processNote"];
            this.rejectionNote = _data["rejectionNote"];
            this.isAccepted = _data["isAccepted"];
            this.isRejected = _data["isRejected"];
            this.isPaid = _data["isPaid"];
            this.bookingNumber = _data["bookingNumber"];
            this.totalCost = _data["totalCost"];
            this.bookingStatusId = _data["bookingStatusId"];
            this.shippingCostTax = _data["shippingCostTax"];
            this.trackingNumber = _data["trackingNumber"];
            this.bookingStatus = _data["bookingStatus"] ? IntlBookingStatus.fromJS(_data["bookingStatus"]) : <any>undefined;
            this.receivedAt = _data["receivedAt"] ? moment(_data["receivedAt"].toString()) : <any>undefined;
            this.numberOfProcessedWebsites = _data["numberOfProcessedWebsites"];
            if (Array.isArray(_data["checkoutAssistanceWebsites"])) {
                this.checkoutAssistanceWebsites = [] as any;
                for (let item of _data["checkoutAssistanceWebsites"])
                    this.checkoutAssistanceWebsites.push(CheckoutAssistanceWebsite.fromJS(item));
            }
            if (Array.isArray(_data["checkoutAssistanceStatus"])) {
                this.checkoutAssistanceStatus = [] as any;
                for (let item of _data["checkoutAssistanceStatus"])
                    this.checkoutAssistanceStatus.push(CheckoutAssistanceStatus.fromJS(item));
            }
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments.push(Payment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckoutAssistance {
        data = typeof data === 'object' ? data : {};
        let result = new CheckoutAssistance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["customerName"] = this.customerName;
        data["customerPhone"] = this.customerPhone;
        data["customerAddress"] = this.customerAddress;
        data["checkoutProcessing"] = this.checkoutProcessing;
        data["pickupCenter"] = this.pickupCenter;
        data["shipToState"] = this.shipToState;
        data["deliveryLocationId"] = this.deliveryLocationId;
        data["deliveryLocation"] = this.deliveryLocation ? this.deliveryLocation.toJSON() : <any>undefined;
        data["processNote"] = this.processNote;
        data["rejectionNote"] = this.rejectionNote;
        data["isAccepted"] = this.isAccepted;
        data["isRejected"] = this.isRejected;
        data["isPaid"] = this.isPaid;
        data["bookingNumber"] = this.bookingNumber;
        data["totalCost"] = this.totalCost;
        data["bookingStatusId"] = this.bookingStatusId;
        data["shippingCostTax"] = this.shippingCostTax;
        data["trackingNumber"] = this.trackingNumber;
        data["bookingStatus"] = this.bookingStatus ? this.bookingStatus.toJSON() : <any>undefined;
        data["receivedAt"] = this.receivedAt ? this.receivedAt.toISOString() : <any>undefined;
        data["numberOfProcessedWebsites"] = this.numberOfProcessedWebsites;
        if (Array.isArray(this.checkoutAssistanceWebsites)) {
            data["checkoutAssistanceWebsites"] = [];
            for (let item of this.checkoutAssistanceWebsites)
                data["checkoutAssistanceWebsites"].push(item.toJSON());
        }
        if (Array.isArray(this.checkoutAssistanceStatus)) {
            data["checkoutAssistanceStatus"] = [];
            for (let item of this.checkoutAssistanceStatus)
                data["checkoutAssistanceStatus"].push(item.toJSON());
        }
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CheckoutAssistance {
        const json = this.toJSON();
        let result = new CheckoutAssistance();
        result.init(json);
        return result;
    }
}

export interface ICheckoutAssistance {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    customerName: string;
    customerPhone: string;
    customerAddress: string | undefined;
    checkoutProcessing: string | undefined;
    pickupCenter: string | undefined;
    shipToState: string | undefined;
    deliveryLocationId: number | undefined;
    deliveryLocation: Location | undefined;
    processNote: string | undefined;
    rejectionNote: string | undefined;
    isAccepted: boolean | undefined;
    isRejected: boolean | undefined;
    isPaid: boolean | undefined;
    bookingNumber: string | undefined;
    totalCost: number | undefined;
    bookingStatusId: number | undefined;
    shippingCostTax: number | undefined;
    trackingNumber: string | undefined;
    bookingStatus: IntlBookingStatus | undefined;
    receivedAt: moment.Moment | undefined;
    numberOfProcessedWebsites: number | undefined;
    checkoutAssistanceWebsites: CheckoutAssistanceWebsite[] | undefined;
    checkoutAssistanceStatus: CheckoutAssistanceStatus[] | undefined;
    payments: Payment[] | undefined;
}

export class Invoice implements IInvoice {
    id: number | undefined;
    customerId: string;
    billToFullName: string;
    billToEmail: string;
    billToPhone: string;
    shipToFullName: string;
    kindOfBooking: string;
    foreignCountry: string;
    weight: number;
    exchangeRate: number;
    deliveryCost: number;
    grandTotal: number;
    dueDate: moment.Moment;
    invoiceNumber: string | undefined;
    terms: string;
    adminFee: number;
    pricePerUnitWeight: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    isPaid: boolean | undefined;
    shippingBatchId: number | undefined;
    paidAt: moment.Moment | undefined;
    customer: Customer | undefined;

    constructor(data?: IInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.billToFullName = _data["billToFullName"];
            this.billToEmail = _data["billToEmail"];
            this.billToPhone = _data["billToPhone"];
            this.shipToFullName = _data["shipToFullName"];
            this.kindOfBooking = _data["kindOfBooking"];
            this.foreignCountry = _data["foreignCountry"];
            this.weight = _data["weight"];
            this.exchangeRate = _data["exchangeRate"];
            this.deliveryCost = _data["deliveryCost"];
            this.grandTotal = _data["grandTotal"];
            this.dueDate = _data["dueDate"] ? moment(_data["dueDate"].toString()) : <any>undefined;
            this.invoiceNumber = _data["invoiceNumber"];
            this.terms = _data["terms"];
            this.adminFee = _data["adminFee"];
            this.pricePerUnitWeight = _data["pricePerUnitWeight"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.isPaid = _data["isPaid"];
            this.shippingBatchId = _data["shippingBatchId"];
            this.paidAt = _data["paidAt"] ? moment(_data["paidAt"].toString()) : <any>undefined;
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["billToFullName"] = this.billToFullName;
        data["billToEmail"] = this.billToEmail;
        data["billToPhone"] = this.billToPhone;
        data["shipToFullName"] = this.shipToFullName;
        data["kindOfBooking"] = this.kindOfBooking;
        data["foreignCountry"] = this.foreignCountry;
        data["weight"] = this.weight;
        data["exchangeRate"] = this.exchangeRate;
        data["deliveryCost"] = this.deliveryCost;
        data["grandTotal"] = this.grandTotal;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["invoiceNumber"] = this.invoiceNumber;
        data["terms"] = this.terms;
        data["adminFee"] = this.adminFee;
        data["pricePerUnitWeight"] = this.pricePerUnitWeight;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["isPaid"] = this.isPaid;
        data["shippingBatchId"] = this.shippingBatchId;
        data["paidAt"] = this.paidAt ? this.paidAt.toISOString() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): Invoice {
        const json = this.toJSON();
        let result = new Invoice();
        result.init(json);
        return result;
    }
}

export interface IInvoice {
    id: number | undefined;
    customerId: string;
    billToFullName: string;
    billToEmail: string;
    billToPhone: string;
    shipToFullName: string;
    kindOfBooking: string;
    foreignCountry: string;
    weight: number;
    exchangeRate: number;
    deliveryCost: number;
    grandTotal: number;
    dueDate: moment.Moment;
    invoiceNumber: string | undefined;
    terms: string;
    adminFee: number;
    pricePerUnitWeight: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    isPaid: boolean | undefined;
    shippingBatchId: number | undefined;
    paidAt: moment.Moment | undefined;
    customer: Customer | undefined;
}

export class ShipmentMode implements IShipmentMode {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IShipmentMode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ShipmentMode {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentMode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): ShipmentMode {
        const json = this.toJSON();
        let result = new ShipmentMode();
        result.init(json);
        return result;
    }
}

export interface IShipmentMode {
    id: number | undefined;
    name: string | undefined;
}

export class ShipmentDeliveryType implements IShipmentDeliveryType {
    id: number | undefined;
    name: string | undefined;
    internationalBookings: InternationalBooking[] | undefined;

    constructor(data?: IShipmentDeliveryType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["internationalBookings"])) {
                this.internationalBookings = [] as any;
                for (let item of _data["internationalBookings"])
                    this.internationalBookings.push(InternationalBooking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShipmentDeliveryType {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentDeliveryType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.internationalBookings)) {
            data["internationalBookings"] = [];
            for (let item of this.internationalBookings)
                data["internationalBookings"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ShipmentDeliveryType {
        const json = this.toJSON();
        let result = new ShipmentDeliveryType();
        result.init(json);
        return result;
    }
}

export interface IShipmentDeliveryType {
    id: number | undefined;
    name: string | undefined;
    internationalBookings: InternationalBooking[] | undefined;
}

export class HoldInstruction implements IHoldInstruction {
    internationalBookingId: number | undefined;
    shippingDate: moment.Moment;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    comment: string | undefined;
    internationalBooking: InternationalBooking | undefined;

    constructor(data?: IHoldInstruction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internationalBookingId = _data["internationalBookingId"];
            this.shippingDate = _data["shippingDate"] ? moment(_data["shippingDate"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.comment = _data["comment"];
            this.internationalBooking = _data["internationalBooking"] ? InternationalBooking.fromJS(_data["internationalBooking"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HoldInstruction {
        data = typeof data === 'object' ? data : {};
        let result = new HoldInstruction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internationalBookingId"] = this.internationalBookingId;
        data["shippingDate"] = this.shippingDate ? this.shippingDate.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        data["internationalBooking"] = this.internationalBooking ? this.internationalBooking.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HoldInstruction {
        const json = this.toJSON();
        let result = new HoldInstruction();
        result.init(json);
        return result;
    }
}

export interface IHoldInstruction {
    internationalBookingId: number | undefined;
    shippingDate: moment.Moment;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    comment: string | undefined;
    internationalBooking: InternationalBooking | undefined;
}

export class ShippingBatch implements IShippingBatch {
    id: number | undefined;
    name: string | undefined;
    createdAt: moment.Moment | undefined;
    internationalBookings: InternationalBooking[] | undefined;

    constructor(data?: IShippingBatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["internationalBookings"])) {
                this.internationalBookings = [] as any;
                for (let item of _data["internationalBookings"])
                    this.internationalBookings.push(InternationalBooking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShippingBatch {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingBatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (Array.isArray(this.internationalBookings)) {
            data["internationalBookings"] = [];
            for (let item of this.internationalBookings)
                data["internationalBookings"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ShippingBatch {
        const json = this.toJSON();
        let result = new ShippingBatch();
        result.init(json);
        return result;
    }
}

export interface IShippingBatch {
    id: number | undefined;
    name: string | undefined;
    createdAt: moment.Moment | undefined;
    internationalBookings: InternationalBooking[] | undefined;
}

export class IntlStatusTimeline implements IIntlStatusTimeline {
    id: number | undefined;
    internationalBookingId: number | undefined;
    comment: string | undefined;
    createdAt: moment.Moment | undefined;
    internationalBooking: InternationalBooking | undefined;

    constructor(data?: IIntlStatusTimeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.internationalBookingId = _data["internationalBookingId"];
            this.comment = _data["comment"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.internationalBooking = _data["internationalBooking"] ? InternationalBooking.fromJS(_data["internationalBooking"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IntlStatusTimeline {
        data = typeof data === 'object' ? data : {};
        let result = new IntlStatusTimeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["internationalBookingId"] = this.internationalBookingId;
        data["comment"] = this.comment;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["internationalBooking"] = this.internationalBooking ? this.internationalBooking.toJSON() : <any>undefined;
        return data; 
    }

    clone(): IntlStatusTimeline {
        const json = this.toJSON();
        let result = new IntlStatusTimeline();
        result.init(json);
        return result;
    }
}

export interface IIntlStatusTimeline {
    id: number | undefined;
    internationalBookingId: number | undefined;
    comment: string | undefined;
    createdAt: moment.Moment | undefined;
    internationalBooking: InternationalBooking | undefined;
}

export class IntlBookingStatus implements IIntlBookingStatus {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IIntlBookingStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IntlBookingStatus {
        data = typeof data === 'object' ? data : {};
        let result = new IntlBookingStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): IntlBookingStatus {
        const json = this.toJSON();
        let result = new IntlBookingStatus();
        result.init(json);
        return result;
    }
}

export interface IIntlBookingStatus {
    id: number | undefined;
    name: string | undefined;
}

export class CheckoutAssistanceWebsite implements ICheckoutAssistanceWebsite {
    id: number | undefined;
    website: string | undefined;
    serviceCharge: number | undefined;
    checkoutAssistanceId: number | undefined;
    checkoutAssistance: CheckoutAssistance | undefined;
    checkoutAssistanceProducts: CheckoutAssistanceProduct[] | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    productsCost: number | undefined;
    shippingCost: number | undefined;
    isProcessed: boolean | undefined;
    country: string | undefined;
    exchangeRate: number | undefined;

    constructor(data?: ICheckoutAssistanceWebsite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.website = _data["website"];
            this.serviceCharge = _data["serviceCharge"];
            this.checkoutAssistanceId = _data["checkoutAssistanceId"];
            this.checkoutAssistance = _data["checkoutAssistance"] ? CheckoutAssistance.fromJS(_data["checkoutAssistance"]) : <any>undefined;
            if (Array.isArray(_data["checkoutAssistanceProducts"])) {
                this.checkoutAssistanceProducts = [] as any;
                for (let item of _data["checkoutAssistanceProducts"])
                    this.checkoutAssistanceProducts.push(CheckoutAssistanceProduct.fromJS(item));
            }
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.productsCost = _data["productsCost"];
            this.shippingCost = _data["shippingCost"];
            this.isProcessed = _data["isProcessed"];
            this.country = _data["country"];
            this.exchangeRate = _data["exchangeRate"];
        }
    }

    static fromJS(data: any): CheckoutAssistanceWebsite {
        data = typeof data === 'object' ? data : {};
        let result = new CheckoutAssistanceWebsite();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["website"] = this.website;
        data["serviceCharge"] = this.serviceCharge;
        data["checkoutAssistanceId"] = this.checkoutAssistanceId;
        data["checkoutAssistance"] = this.checkoutAssistance ? this.checkoutAssistance.toJSON() : <any>undefined;
        if (Array.isArray(this.checkoutAssistanceProducts)) {
            data["checkoutAssistanceProducts"] = [];
            for (let item of this.checkoutAssistanceProducts)
                data["checkoutAssistanceProducts"].push(item.toJSON());
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["productsCost"] = this.productsCost;
        data["shippingCost"] = this.shippingCost;
        data["isProcessed"] = this.isProcessed;
        data["country"] = this.country;
        data["exchangeRate"] = this.exchangeRate;
        return data; 
    }

    clone(): CheckoutAssistanceWebsite {
        const json = this.toJSON();
        let result = new CheckoutAssistanceWebsite();
        result.init(json);
        return result;
    }
}

export interface ICheckoutAssistanceWebsite {
    id: number | undefined;
    website: string | undefined;
    serviceCharge: number | undefined;
    checkoutAssistanceId: number | undefined;
    checkoutAssistance: CheckoutAssistance | undefined;
    checkoutAssistanceProducts: CheckoutAssistanceProduct[] | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    productsCost: number | undefined;
    shippingCost: number | undefined;
    isProcessed: boolean | undefined;
    country: string | undefined;
    exchangeRate: number | undefined;
}

export class CheckoutAssistanceStatus implements ICheckoutAssistanceStatus {
    id: number | undefined;
    checkoutAssistanceId: number | undefined;
    status: string | undefined;
    createdAt: moment.Moment | undefined;
    checkoutAssistance: CheckoutAssistance | undefined;

    constructor(data?: ICheckoutAssistanceStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkoutAssistanceId = _data["checkoutAssistanceId"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.checkoutAssistance = _data["checkoutAssistance"] ? CheckoutAssistance.fromJS(_data["checkoutAssistance"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CheckoutAssistanceStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CheckoutAssistanceStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkoutAssistanceId"] = this.checkoutAssistanceId;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["checkoutAssistance"] = this.checkoutAssistance ? this.checkoutAssistance.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CheckoutAssistanceStatus {
        const json = this.toJSON();
        let result = new CheckoutAssistanceStatus();
        result.init(json);
        return result;
    }
}

export interface ICheckoutAssistanceStatus {
    id: number | undefined;
    checkoutAssistanceId: number | undefined;
    status: string | undefined;
    createdAt: moment.Moment | undefined;
    checkoutAssistance: CheckoutAssistance | undefined;
}

export class CheckoutAssistanceProduct implements ICheckoutAssistanceProduct {
    id: number | undefined;
    name: string;
    url: string;
    color: string | undefined;
    delivery: string | undefined;
    size: string | undefined;
    style: string | undefined;
    itemNumber: string | undefined;
    quantity: number;
    comment: string | undefined;
    checkoutAssistanceWebsiteId: number | undefined;
    checkoutAssistanceWebsite: CheckoutAssistanceWebsite | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;

    constructor(data?: ICheckoutAssistanceProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.color = _data["color"];
            this.delivery = _data["delivery"];
            this.size = _data["size"];
            this.style = _data["style"];
            this.itemNumber = _data["itemNumber"];
            this.quantity = _data["quantity"];
            this.comment = _data["comment"];
            this.checkoutAssistanceWebsiteId = _data["checkoutAssistanceWebsiteId"];
            this.checkoutAssistanceWebsite = _data["checkoutAssistanceWebsite"] ? CheckoutAssistanceWebsite.fromJS(_data["checkoutAssistanceWebsite"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CheckoutAssistanceProduct {
        data = typeof data === 'object' ? data : {};
        let result = new CheckoutAssistanceProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        data["color"] = this.color;
        data["delivery"] = this.delivery;
        data["size"] = this.size;
        data["style"] = this.style;
        data["itemNumber"] = this.itemNumber;
        data["quantity"] = this.quantity;
        data["comment"] = this.comment;
        data["checkoutAssistanceWebsiteId"] = this.checkoutAssistanceWebsiteId;
        data["checkoutAssistanceWebsite"] = this.checkoutAssistanceWebsite ? this.checkoutAssistanceWebsite.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CheckoutAssistanceProduct {
        const json = this.toJSON();
        let result = new CheckoutAssistanceProduct();
        result.init(json);
        return result;
    }
}

export interface ICheckoutAssistanceProduct {
    id: number | undefined;
    name: string;
    url: string;
    color: string | undefined;
    delivery: string | undefined;
    size: string | undefined;
    style: string | undefined;
    itemNumber: string | undefined;
    quantity: number;
    comment: string | undefined;
    checkoutAssistanceWebsiteId: number | undefined;
    checkoutAssistanceWebsite: CheckoutAssistanceWebsite | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
}

export class RegisterUserVieModel implements IRegisterUserVieModel {
    email: string;
    fullName: string | undefined;
    password: string;
    confirmPassword: string | undefined;
    userType: RegisterUserVieModelUserType;
    businessName: string | undefined;
    businessAnniversary: moment.Moment | undefined;
    tcAccepted: boolean | undefined;
    profileUrl: string | undefined;

    constructor(data?: IRegisterUserVieModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.userType = _data["userType"];
            this.businessName = _data["businessName"];
            this.businessAnniversary = _data["businessAnniversary"] ? moment(_data["businessAnniversary"].toString()) : <any>undefined;
            this.tcAccepted = _data["tcAccepted"];
            this.profileUrl = _data["profileUrl"];
        }
    }

    static fromJS(data: any): RegisterUserVieModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserVieModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["userType"] = this.userType;
        data["businessName"] = this.businessName;
        data["businessAnniversary"] = this.businessAnniversary ? this.businessAnniversary.toISOString() : <any>undefined;
        data["tcAccepted"] = this.tcAccepted;
        data["profileUrl"] = this.profileUrl;
        return data; 
    }

    clone(): RegisterUserVieModel {
        const json = this.toJSON();
        let result = new RegisterUserVieModel();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserVieModel {
    email: string;
    fullName: string | undefined;
    password: string;
    confirmPassword: string | undefined;
    userType: RegisterUserVieModelUserType;
    businessName: string | undefined;
    businessAnniversary: moment.Moment | undefined;
    tcAccepted: boolean | undefined;
    profileUrl: string | undefined;
}

export class ObjectResourceOfRegisterUserResource implements IObjectResourceOfRegisterUserResource {
    data: RegisterUserResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfRegisterUserResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? RegisterUserResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfRegisterUserResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfRegisterUserResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfRegisterUserResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfRegisterUserResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfRegisterUserResource {
    data: RegisterUserResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class RegisterUserResource implements IRegisterUserResource {
    token: string | undefined;
    userId: string | undefined;
    userType: RegisterUserResourceUserType | undefined;
    isProfileComplete: boolean | undefined;
    user: AspNetUser | undefined;
    role: AspNetRole[] | undefined;
    customer: Customer | undefined;

    constructor(data?: IRegisterUserResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
            this.userType = _data["userType"];
            this.isProfileComplete = _data["isProfileComplete"];
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["role"])) {
                this.role = [] as any;
                for (let item of _data["role"])
                    this.role.push(AspNetRole.fromJS(item));
            }
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterUserResource {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        data["userType"] = this.userType;
        data["isProfileComplete"] = this.isProfileComplete;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.role)) {
            data["role"] = [];
            for (let item of this.role)
                data["role"].push(item.toJSON());
        }
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RegisterUserResource {
        const json = this.toJSON();
        let result = new RegisterUserResource();
        result.init(json);
        return result;
    }
}

export interface IRegisterUserResource {
    token: string | undefined;
    userId: string | undefined;
    userType: RegisterUserResourceUserType | undefined;
    isProfileComplete: boolean | undefined;
    user: AspNetUser | undefined;
    role: AspNetRole[] | undefined;
    customer: Customer | undefined;
}

export class ObjectResourceOfTCResource implements IObjectResourceOfTCResource {
    data: TCResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfTCResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TCResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfTCResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfTCResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfTCResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfTCResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfTCResource {
    data: TCResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class TCResource implements ITCResource {
    tcValue: string | undefined;

    constructor(data?: ITCResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tcValue = _data["tcValue"];
        }
    }

    static fromJS(data: any): TCResource {
        data = typeof data === 'object' ? data : {};
        let result = new TCResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tcValue"] = this.tcValue;
        return data; 
    }

    clone(): TCResource {
        const json = this.toJSON();
        let result = new TCResource();
        result.init(json);
        return result;
    }
}

export interface ITCResource {
    tcValue: string | undefined;
}

export class ListResourceOfCountryResource implements IListResourceOfCountryResource {
    total: number | undefined;
    data: CountryResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfCountryResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(CountryResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfCountryResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfCountryResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfCountryResource {
        const json = this.toJSON();
        let result = new ListResourceOfCountryResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfCountryResource {
    total: number | undefined;
    data: CountryResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class CountryResource implements ICountryResource {
    id: number | undefined;
    name: string | undefined;
    countryCode: string | undefined;

    constructor(data?: ICountryResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): CountryResource {
        data = typeof data === 'object' ? data : {};
        let result = new CountryResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["countryCode"] = this.countryCode;
        return data; 
    }

    clone(): CountryResource {
        const json = this.toJSON();
        let result = new CountryResource();
        result.init(json);
        return result;
    }
}

export interface ICountryResource {
    id: number | undefined;
    name: string | undefined;
    countryCode: string | undefined;
}

export class SocialSignUpViewModel implements ISocialSignUpViewModel {
    email: string | undefined;
    fullName: string | undefined;
    profilePicUrl: string | undefined;

    constructor(data?: ISocialSignUpViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.profilePicUrl = _data["profilePicUrl"];
        }
    }

    static fromJS(data: any): SocialSignUpViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SocialSignUpViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["profilePicUrl"] = this.profilePicUrl;
        return data; 
    }

    clone(): SocialSignUpViewModel {
        const json = this.toJSON();
        let result = new SocialSignUpViewModel();
        result.init(json);
        return result;
    }
}

export interface ISocialSignUpViewModel {
    email: string | undefined;
    fullName: string | undefined;
    profilePicUrl: string | undefined;
}

export class CompleteProfileViewModel implements ICompleteProfileViewModel {
    homeAddress: string;
    residentialCountryId: number;
    residentialStateId: number;
    closestLandmark: string | undefined;
    closestBustopId: number | undefined;
    userId: string | undefined;

    constructor(data?: ICompleteProfileViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.homeAddress = _data["homeAddress"];
            this.residentialCountryId = _data["residentialCountryId"];
            this.residentialStateId = _data["residentialStateId"];
            this.closestLandmark = _data["closestLandmark"];
            this.closestBustopId = _data["closestBustopId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CompleteProfileViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteProfileViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["homeAddress"] = this.homeAddress;
        data["residentialCountryId"] = this.residentialCountryId;
        data["residentialStateId"] = this.residentialStateId;
        data["closestLandmark"] = this.closestLandmark;
        data["closestBustopId"] = this.closestBustopId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): CompleteProfileViewModel {
        const json = this.toJSON();
        let result = new CompleteProfileViewModel();
        result.init(json);
        return result;
    }
}

export interface ICompleteProfileViewModel {
    homeAddress: string;
    residentialCountryId: number;
    residentialStateId: number;
    closestLandmark: string | undefined;
    closestBustopId: number | undefined;
    userId: string | undefined;
}

export class StatusResource implements IStatusResource {
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IStatusResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): StatusResource {
        data = typeof data === 'object' ? data : {};
        let result = new StatusResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): StatusResource {
        const json = this.toJSON();
        let result = new StatusResource();
        result.init(json);
        return result;
    }
}

export interface IStatusResource {
    code: string | undefined;
    message: string | undefined;
}

export class UserPhotoViewModel implements IUserPhotoViewModel {
    file: HttpPostedFileBase;
    userId: string;

    constructor(data?: IUserPhotoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.file = new HttpPostedFileBase();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"] ? HttpPostedFileBase.fromJS(_data["file"]) : new HttpPostedFileBase();
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserPhotoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserPhotoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): UserPhotoViewModel {
        const json = this.toJSON();
        let result = new UserPhotoViewModel();
        result.init(json);
        return result;
    }
}

export interface IUserPhotoViewModel {
    file: HttpPostedFileBase;
    userId: string;
}

export class HttpPostedFileBase implements IHttpPostedFileBase {
    readonly contentLength: number | undefined;
    readonly contentType: string | undefined;
    readonly fileName: string | undefined;
    readonly inputStream: Stream | undefined;

    constructor(data?: IHttpPostedFileBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).contentLength = _data["contentLength"];
            (<any>this).contentType = _data["contentType"];
            (<any>this).fileName = _data["fileName"];
            (<any>this).inputStream = _data["inputStream"] ? Stream.fromJS(_data["inputStream"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HttpPostedFileBase {
        data = typeof data === 'object' ? data : {};
        let result = new HttpPostedFileBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentLength"] = this.contentLength;
        data["contentType"] = this.contentType;
        data["fileName"] = this.fileName;
        data["inputStream"] = this.inputStream ? this.inputStream.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HttpPostedFileBase {
        const json = this.toJSON();
        let result = new HttpPostedFileBase();
        result.init(json);
        return result;
    }
}

export interface IHttpPostedFileBase {
    contentLength: number | undefined;
    contentType: string | undefined;
    fileName: string | undefined;
    inputStream: Stream | undefined;
}

export class Stream implements IStream {
    readonly canRead: boolean | undefined;
    readonly canSeek: boolean | undefined;
    readonly canTimeout: boolean | undefined;
    readonly canWrite: boolean | undefined;
    readonly length: number | undefined;
    position: number | undefined;
    readTimeout: number | undefined;
    writeTimeout: number | undefined;

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canRead = _data["canRead"];
            (<any>this).canSeek = _data["canSeek"];
            (<any>this).canTimeout = _data["canTimeout"];
            (<any>this).canWrite = _data["canWrite"];
            (<any>this).length = _data["length"];
            this.position = _data["position"];
            this.readTimeout = _data["readTimeout"];
            this.writeTimeout = _data["writeTimeout"];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        let result = new Stream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRead"] = this.canRead;
        data["canSeek"] = this.canSeek;
        data["canTimeout"] = this.canTimeout;
        data["canWrite"] = this.canWrite;
        data["length"] = this.length;
        data["position"] = this.position;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        return data; 
    }

    clone(): Stream {
        const json = this.toJSON();
        let result = new Stream();
        result.init(json);
        return result;
    }
}

export interface IStream {
    canRead: boolean | undefined;
    canSeek: boolean | undefined;
    canTimeout: boolean | undefined;
    canWrite: boolean | undefined;
    length: number | undefined;
    position: number | undefined;
    readTimeout: number | undefined;
    writeTimeout: number | undefined;
}

export class VerifiedPhoneUpdate implements IVerifiedPhoneUpdate {
    phone: string | undefined;
    isVerified: boolean | undefined;
    userId: string | undefined;

    constructor(data?: IVerifiedPhoneUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.isVerified = _data["isVerified"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): VerifiedPhoneUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new VerifiedPhoneUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["isVerified"] = this.isVerified;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): VerifiedPhoneUpdate {
        const json = this.toJSON();
        let result = new VerifiedPhoneUpdate();
        result.init(json);
        return result;
    }
}

export interface IVerifiedPhoneUpdate {
    phone: string | undefined;
    isVerified: boolean | undefined;
    userId: string | undefined;
}

export class VmUserObj implements IVmUserObj {
    claimsPrincipal: ClaimsPrincipal | undefined;
    user: AspNetUser | undefined;

    constructor(data?: IVmUserObj) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimsPrincipal = _data["claimsPrincipal"] ? ClaimsPrincipal.fromJS(_data["claimsPrincipal"]) : <any>undefined;
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VmUserObj {
        data = typeof data === 'object' ? data : {};
        let result = new VmUserObj();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimsPrincipal"] = this.claimsPrincipal ? this.claimsPrincipal.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }

    clone(): VmUserObj {
        const json = this.toJSON();
        let result = new VmUserObj();
        result.init(json);
        return result;
    }
}

export interface IVmUserObj {
    claimsPrincipal: ClaimsPrincipal | undefined;
    user: AspNetUser | undefined;
}

export class ClaimsPrincipal implements IClaimsPrincipal {
    readonly claims: Claim[] | undefined;
    readonly identities: ClaimsIdentity[] | undefined;
    readonly identity: IIdentity | undefined;

    constructor(data?: IClaimsPrincipal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claims"])) {
                (<any>this).claims = [] as any;
                for (let item of _data["claims"])
                    (<any>this).claims.push(Claim.fromJS(item));
            }
            if (Array.isArray(_data["identities"])) {
                (<any>this).identities = [] as any;
                for (let item of _data["identities"])
                    (<any>this).identities.push(ClaimsIdentity.fromJS(item));
            }
            (<any>this).identity = _data["identity"] ? IIdentity.fromJS(_data["identity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClaimsPrincipal {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsPrincipal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.identities)) {
            data["identities"] = [];
            for (let item of this.identities)
                data["identities"].push(item.toJSON());
        }
        data["identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ClaimsPrincipal {
        const json = this.toJSON();
        let result = new ClaimsPrincipal();
        result.init(json);
        return result;
    }
}

export interface IClaimsPrincipal {
    claims: Claim[] | undefined;
    identities: ClaimsIdentity[] | undefined;
    identity: IIdentity | undefined;
}

export class Claim implements IClaim {
    readonly issuer: string | undefined;
    readonly originalIssuer: string | undefined;
    readonly properties: { [key: string]: string; } | undefined;
    readonly subject: ClaimsIdentity | undefined;
    readonly type: string | undefined;
    readonly value: string | undefined;
    readonly valueType: string | undefined;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).issuer = _data["issuer"];
            (<any>this).originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this).properties[key] = _data["properties"][key];
                }
            }
            (<any>this).subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>undefined;
            (<any>this).type = _data["type"];
            (<any>this).value = _data["value"];
            (<any>this).valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data; 
    }

    clone(): Claim {
        const json = this.toJSON();
        let result = new Claim();
        result.init(json);
        return result;
    }
}

export interface IClaim {
    issuer: string | undefined;
    originalIssuer: string | undefined;
    properties: { [key: string]: string; } | undefined;
    subject: ClaimsIdentity | undefined;
    type: string | undefined;
    value: string | undefined;
    valueType: string | undefined;
}

export class ClaimsIdentity implements IClaimsIdentity {
    readonly authenticationType: string | undefined;
    readonly isAuthenticated: boolean | undefined;
    actor: ClaimsIdentity | undefined;
    bootstrapContext: any | undefined;
    readonly claims: Claim[] | undefined;
    label: string | undefined;
    readonly name: string | undefined;
    readonly nameClaimType: string | undefined;
    readonly roleClaimType: string | undefined;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).authenticationType = _data["authenticationType"];
            (<any>this).isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>undefined;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                (<any>this).claims = [] as any;
                for (let item of _data["claims"])
                    (<any>this).claims.push(Claim.fromJS(item));
            }
            this.label = _data["label"];
            (<any>this).name = _data["name"];
            (<any>this).nameClaimType = _data["nameClaimType"];
            (<any>this).roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data; 
    }

    clone(): ClaimsIdentity {
        const json = this.toJSON();
        let result = new ClaimsIdentity();
        result.init(json);
        return result;
    }
}

export interface IClaimsIdentity {
    authenticationType: string | undefined;
    isAuthenticated: boolean | undefined;
    actor: ClaimsIdentity | undefined;
    bootstrapContext: any | undefined;
    claims: Claim[] | undefined;
    label: string | undefined;
    name: string | undefined;
    nameClaimType: string | undefined;
    roleClaimType: string | undefined;
}

export class IIdentity implements IIIdentity {
    readonly name: string | undefined;
    readonly authenticationType: string | undefined;
    readonly isAuthenticated: boolean | undefined;

    constructor(data?: IIIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            (<any>this).authenticationType = _data["authenticationType"];
            (<any>this).isAuthenticated = _data["isAuthenticated"];
        }
    }

    static fromJS(data: any): IIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new IIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        return data; 
    }

    clone(): IIdentity {
        const json = this.toJSON();
        let result = new IIdentity();
        result.init(json);
        return result;
    }
}

export interface IIIdentity {
    name: string | undefined;
    authenticationType: string | undefined;
    isAuthenticated: boolean | undefined;
}

export class FormData implements IFormData {
    action: string | undefined;
    number: number | undefined;
    offset: number | undefined;

    constructor(data?: IFormData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.number = _data["number"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): FormData {
        data = typeof data === 'object' ? data : {};
        let result = new FormData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["number"] = this.number;
        data["offset"] = this.offset;
        return data; 
    }

    clone(): FormData {
        const json = this.toJSON();
        let result = new FormData();
        result.init(json);
        return result;
    }
}

export interface IFormData {
    action: string | undefined;
    number: number | undefined;
    offset: number | undefined;
}

export class CreateLocalBooking implements ICreateLocalBooking {
    deliveryAddress: string;
    deliveryBustop: string;
    pickupAddress: string | undefined;
    pickupBustop: string | undefined;
    customerPhoneNumber: string;
    customerFullName: string;
    senderPhoneNumber: string | undefined;
    senderFullName: string | undefined;
    packageDescription: string;
    usePartnerProfile: boolean | undefined;
    category: string | undefined;

    constructor(data?: ICreateLocalBooking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryAddress = _data["deliveryAddress"];
            this.deliveryBustop = _data["deliveryBustop"];
            this.pickupAddress = _data["pickupAddress"];
            this.pickupBustop = _data["pickupBustop"];
            this.customerPhoneNumber = _data["customerPhoneNumber"];
            this.customerFullName = _data["customerFullName"];
            this.senderPhoneNumber = _data["senderPhoneNumber"];
            this.senderFullName = _data["senderFullName"];
            this.packageDescription = _data["packageDescription"];
            this.usePartnerProfile = _data["usePartnerProfile"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): CreateLocalBooking {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLocalBooking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryAddress"] = this.deliveryAddress;
        data["deliveryBustop"] = this.deliveryBustop;
        data["pickupAddress"] = this.pickupAddress;
        data["pickupBustop"] = this.pickupBustop;
        data["customerPhoneNumber"] = this.customerPhoneNumber;
        data["customerFullName"] = this.customerFullName;
        data["senderPhoneNumber"] = this.senderPhoneNumber;
        data["senderFullName"] = this.senderFullName;
        data["packageDescription"] = this.packageDescription;
        data["usePartnerProfile"] = this.usePartnerProfile;
        data["category"] = this.category;
        return data; 
    }

    clone(): CreateLocalBooking {
        const json = this.toJSON();
        let result = new CreateLocalBooking();
        result.init(json);
        return result;
    }
}

export interface ICreateLocalBooking {
    deliveryAddress: string;
    deliveryBustop: string;
    pickupAddress: string | undefined;
    pickupBustop: string | undefined;
    customerPhoneNumber: string;
    customerFullName: string;
    senderPhoneNumber: string | undefined;
    senderFullName: string | undefined;
    packageDescription: string;
    usePartnerProfile: boolean | undefined;
    category: string | undefined;
}

export class ListResourceOfIntlBookingStatusResource implements IListResourceOfIntlBookingStatusResource {
    total: number | undefined;
    data: IntlBookingStatusResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfIntlBookingStatusResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(IntlBookingStatusResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfIntlBookingStatusResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfIntlBookingStatusResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfIntlBookingStatusResource {
        const json = this.toJSON();
        let result = new ListResourceOfIntlBookingStatusResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfIntlBookingStatusResource {
    total: number | undefined;
    data: IntlBookingStatusResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class IntlBookingStatusResource implements IIntlBookingStatusResource {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IIntlBookingStatusResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IntlBookingStatusResource {
        data = typeof data === 'object' ? data : {};
        let result = new IntlBookingStatusResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): IntlBookingStatusResource {
        const json = this.toJSON();
        let result = new IntlBookingStatusResource();
        result.init(json);
        return result;
    }
}

export interface IIntlBookingStatusResource {
    id: number | undefined;
    name: string | undefined;
}

export class ListResourceOfShippingBatchResource implements IListResourceOfShippingBatchResource {
    total: number | undefined;
    data: ShippingBatchResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfShippingBatchResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ShippingBatchResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfShippingBatchResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfShippingBatchResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfShippingBatchResource {
        const json = this.toJSON();
        let result = new ListResourceOfShippingBatchResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfShippingBatchResource {
    total: number | undefined;
    data: ShippingBatchResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class ShippingBatchResource implements IShippingBatchResource {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IShippingBatchResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ShippingBatchResource {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingBatchResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): ShippingBatchResource {
        const json = this.toJSON();
        let result = new ShippingBatchResource();
        result.init(json);
        return result;
    }
}

export interface IShippingBatchResource {
    id: number | undefined;
    name: string | undefined;
}

export class ListResourceOfShipmentModeResource implements IListResourceOfShipmentModeResource {
    total: number | undefined;
    data: ShipmentModeResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfShipmentModeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ShipmentModeResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfShipmentModeResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfShipmentModeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfShipmentModeResource {
        const json = this.toJSON();
        let result = new ListResourceOfShipmentModeResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfShipmentModeResource {
    total: number | undefined;
    data: ShipmentModeResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class ShipmentModeResource implements IShipmentModeResource {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IShipmentModeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ShipmentModeResource {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentModeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): ShipmentModeResource {
        const json = this.toJSON();
        let result = new ShipmentModeResource();
        result.init(json);
        return result;
    }
}

export interface IShipmentModeResource {
    id: number | undefined;
    name: string | undefined;
}

export class ListResourceOfShipmentDeliveryTypeResource implements IListResourceOfShipmentDeliveryTypeResource {
    total: number | undefined;
    data: ShipmentDeliveryTypeResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfShipmentDeliveryTypeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ShipmentDeliveryTypeResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfShipmentDeliveryTypeResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfShipmentDeliveryTypeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfShipmentDeliveryTypeResource {
        const json = this.toJSON();
        let result = new ListResourceOfShipmentDeliveryTypeResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfShipmentDeliveryTypeResource {
    total: number | undefined;
    data: ShipmentDeliveryTypeResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class ShipmentDeliveryTypeResource implements IShipmentDeliveryTypeResource {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IShipmentDeliveryTypeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ShipmentDeliveryTypeResource {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentDeliveryTypeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): ShipmentDeliveryTypeResource {
        const json = this.toJSON();
        let result = new ShipmentDeliveryTypeResource();
        result.init(json);
        return result;
    }
}

export interface IShipmentDeliveryTypeResource {
    id: number | undefined;
    name: string | undefined;
}

export class InternationalBookingCtreatDTO implements IInternationalBookingCtreatDTO {
    zipCode: number | undefined;
    postCode: number | undefined;
    shipmentModeId: number | undefined;
    localHomeDeliveryTypeId: number | undefined;
    shipmentDeliveryTypeId: number;
    country: string;
    pickupContactName: string | undefined;
    pickupAddress: string | undefined;
    pickupContactPhone: string | undefined;
    homeDelivery: boolean | undefined;
    recipientName: string | undefined;
    packageValue: number | undefined;
    deliveryAddress: string | undefined;
    recipientPhone: string | undefined;
    estimatedPackageWeight: number | undefined;
    pickup: boolean | undefined;
    estimatedPackageSize: string | undefined;
    packageDescription: string;
    kindOfBooking: string | undefined;
    eta: moment.Moment | undefined;
    homeDeliveryLocationId: number | undefined;
    pickupLocationId: number | undefined;

    constructor(data?: IInternationalBookingCtreatDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zipCode = _data["zipCode"];
            this.postCode = _data["postCode"];
            this.shipmentModeId = _data["shipmentModeId"];
            this.localHomeDeliveryTypeId = _data["localHomeDeliveryTypeId"];
            this.shipmentDeliveryTypeId = _data["shipmentDeliveryTypeId"];
            this.country = _data["country"];
            this.pickupContactName = _data["pickupContactName"];
            this.pickupAddress = _data["pickupAddress"];
            this.pickupContactPhone = _data["pickupContactPhone"];
            this.homeDelivery = _data["homeDelivery"];
            this.recipientName = _data["recipientName"];
            this.packageValue = _data["packageValue"];
            this.deliveryAddress = _data["deliveryAddress"];
            this.recipientPhone = _data["recipientPhone"];
            this.estimatedPackageWeight = _data["estimatedPackageWeight"];
            this.pickup = _data["pickup"];
            this.estimatedPackageSize = _data["estimatedPackageSize"];
            this.packageDescription = _data["packageDescription"];
            this.kindOfBooking = _data["kindOfBooking"];
            this.eta = _data["eta"] ? moment(_data["eta"].toString()) : <any>undefined;
            this.homeDeliveryLocationId = _data["homeDeliveryLocationId"];
            this.pickupLocationId = _data["pickupLocationId"];
        }
    }

    static fromJS(data: any): InternationalBookingCtreatDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InternationalBookingCtreatDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zipCode"] = this.zipCode;
        data["postCode"] = this.postCode;
        data["shipmentModeId"] = this.shipmentModeId;
        data["localHomeDeliveryTypeId"] = this.localHomeDeliveryTypeId;
        data["shipmentDeliveryTypeId"] = this.shipmentDeliveryTypeId;
        data["country"] = this.country;
        data["pickupContactName"] = this.pickupContactName;
        data["pickupAddress"] = this.pickupAddress;
        data["pickupContactPhone"] = this.pickupContactPhone;
        data["homeDelivery"] = this.homeDelivery;
        data["recipientName"] = this.recipientName;
        data["packageValue"] = this.packageValue;
        data["deliveryAddress"] = this.deliveryAddress;
        data["recipientPhone"] = this.recipientPhone;
        data["estimatedPackageWeight"] = this.estimatedPackageWeight;
        data["pickup"] = this.pickup;
        data["estimatedPackageSize"] = this.estimatedPackageSize;
        data["packageDescription"] = this.packageDescription;
        data["kindOfBooking"] = this.kindOfBooking;
        data["eta"] = this.eta ? this.eta.toISOString() : <any>undefined;
        data["homeDeliveryLocationId"] = this.homeDeliveryLocationId;
        data["pickupLocationId"] = this.pickupLocationId;
        return data; 
    }

    clone(): InternationalBookingCtreatDTO {
        const json = this.toJSON();
        let result = new InternationalBookingCtreatDTO();
        result.init(json);
        return result;
    }
}

export interface IInternationalBookingCtreatDTO {
    zipCode: number | undefined;
    postCode: number | undefined;
    shipmentModeId: number | undefined;
    localHomeDeliveryTypeId: number | undefined;
    shipmentDeliveryTypeId: number;
    country: string;
    pickupContactName: string | undefined;
    pickupAddress: string | undefined;
    pickupContactPhone: string | undefined;
    homeDelivery: boolean | undefined;
    recipientName: string | undefined;
    packageValue: number | undefined;
    deliveryAddress: string | undefined;
    recipientPhone: string | undefined;
    estimatedPackageWeight: number | undefined;
    pickup: boolean | undefined;
    estimatedPackageSize: string | undefined;
    packageDescription: string;
    kindOfBooking: string | undefined;
    eta: moment.Moment | undefined;
    homeDeliveryLocationId: number | undefined;
    pickupLocationId: number | undefined;
}

export class ObjectResourceOfIntlCreateResource implements IObjectResourceOfIntlCreateResource {
    data: IntlCreateResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfIntlCreateResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? IntlCreateResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfIntlCreateResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfIntlCreateResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfIntlCreateResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfIntlCreateResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfIntlCreateResource {
    data: IntlCreateResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class IntlCreateResource implements IIntlCreateResource {
    id: number | undefined;
    bookingNumber: string | undefined;
    successMessage: string | undefined;
    customer: Customer | undefined;

    constructor(data?: IIntlCreateResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bookingNumber = _data["bookingNumber"];
            this.successMessage = _data["successMessage"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IntlCreateResource {
        data = typeof data === 'object' ? data : {};
        let result = new IntlCreateResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bookingNumber"] = this.bookingNumber;
        data["successMessage"] = this.successMessage;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): IntlCreateResource {
        const json = this.toJSON();
        let result = new IntlCreateResource();
        result.init(json);
        return result;
    }
}

export interface IIntlCreateResource {
    id: number | undefined;
    bookingNumber: string | undefined;
    successMessage: string | undefined;
    customer: Customer | undefined;
}

export class ObjectResourceOfHoldInstructionResource implements IObjectResourceOfHoldInstructionResource {
    data: HoldInstructionResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfHoldInstructionResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? HoldInstructionResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfHoldInstructionResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfHoldInstructionResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfHoldInstructionResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfHoldInstructionResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfHoldInstructionResource {
    data: HoldInstructionResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class HoldInstructionResource implements IHoldInstructionResource {
    intlBookingForHoldInstruction: IntlBookingForHoldInstruction[] | undefined;
    holdInstructionDates: HoldInstructionDates[] | undefined;

    constructor(data?: IHoldInstructionResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["intlBookingForHoldInstruction"])) {
                this.intlBookingForHoldInstruction = [] as any;
                for (let item of _data["intlBookingForHoldInstruction"])
                    this.intlBookingForHoldInstruction.push(IntlBookingForHoldInstruction.fromJS(item));
            }
            if (Array.isArray(_data["holdInstructionDates"])) {
                this.holdInstructionDates = [] as any;
                for (let item of _data["holdInstructionDates"])
                    this.holdInstructionDates.push(HoldInstructionDates.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HoldInstructionResource {
        data = typeof data === 'object' ? data : {};
        let result = new HoldInstructionResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.intlBookingForHoldInstruction)) {
            data["intlBookingForHoldInstruction"] = [];
            for (let item of this.intlBookingForHoldInstruction)
                data["intlBookingForHoldInstruction"].push(item.toJSON());
        }
        if (Array.isArray(this.holdInstructionDates)) {
            data["holdInstructionDates"] = [];
            for (let item of this.holdInstructionDates)
                data["holdInstructionDates"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HoldInstructionResource {
        const json = this.toJSON();
        let result = new HoldInstructionResource();
        result.init(json);
        return result;
    }
}

export interface IHoldInstructionResource {
    intlBookingForHoldInstruction: IntlBookingForHoldInstruction[] | undefined;
    holdInstructionDates: HoldInstructionDates[] | undefined;
}

export class IntlBookingForHoldInstruction implements IIntlBookingForHoldInstruction {
    id: number | undefined;
    bookingNumber: string | undefined;

    constructor(data?: IIntlBookingForHoldInstruction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bookingNumber = _data["bookingNumber"];
        }
    }

    static fromJS(data: any): IntlBookingForHoldInstruction {
        data = typeof data === 'object' ? data : {};
        let result = new IntlBookingForHoldInstruction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bookingNumber"] = this.bookingNumber;
        return data; 
    }

    clone(): IntlBookingForHoldInstruction {
        const json = this.toJSON();
        let result = new IntlBookingForHoldInstruction();
        result.init(json);
        return result;
    }
}

export interface IIntlBookingForHoldInstruction {
    id: number | undefined;
    bookingNumber: string | undefined;
}

export class HoldInstructionDates implements IHoldInstructionDates {
    dates: string | undefined;

    constructor(data?: IHoldInstructionDates) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dates = _data["dates"];
        }
    }

    static fromJS(data: any): HoldInstructionDates {
        data = typeof data === 'object' ? data : {};
        let result = new HoldInstructionDates();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dates"] = this.dates;
        return data; 
    }

    clone(): HoldInstructionDates {
        const json = this.toJSON();
        let result = new HoldInstructionDates();
        result.init(json);
        return result;
    }
}

export interface IHoldInstructionDates {
    dates: string | undefined;
}

export class HoldInstructionDTO implements IHoldInstructionDTO {
    internationalBookingId: number;
    shippingDate: moment.Moment;
    comment: string;

    constructor(data?: IHoldInstructionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.internationalBookingId = _data["internationalBookingId"];
            this.shippingDate = _data["shippingDate"] ? moment(_data["shippingDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): HoldInstructionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new HoldInstructionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internationalBookingId"] = this.internationalBookingId;
        data["shippingDate"] = this.shippingDate ? this.shippingDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): HoldInstructionDTO {
        const json = this.toJSON();
        let result = new HoldInstructionDTO();
        result.init(json);
        return result;
    }
}

export interface IHoldInstructionDTO {
    internationalBookingId: number;
    shippingDate: moment.Moment;
    comment: string;
}

export class AddILStatusViewModelDTO implements IAddILStatusViewModelDTO {
    id: number;
    status: string | undefined;
    bookingNumber: string | undefined;
    bookingStatus: number | undefined;

    constructor(data?: IAddILStatusViewModelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.bookingNumber = _data["bookingNumber"];
            this.bookingStatus = _data["bookingStatus"];
        }
    }

    static fromJS(data: any): AddILStatusViewModelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddILStatusViewModelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["bookingNumber"] = this.bookingNumber;
        data["bookingStatus"] = this.bookingStatus;
        return data; 
    }

    clone(): AddILStatusViewModelDTO {
        const json = this.toJSON();
        let result = new AddILStatusViewModelDTO();
        result.init(json);
        return result;
    }
}

export interface IAddILStatusViewModelDTO {
    id: number;
    status: string | undefined;
    bookingNumber: string | undefined;
    bookingStatus: number | undefined;
}

export class ObjectResourceOfInternationalBookingResource implements IObjectResourceOfInternationalBookingResource {
    data: InternationalBookingResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfInternationalBookingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? InternationalBookingResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfInternationalBookingResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfInternationalBookingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfInternationalBookingResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfInternationalBookingResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfInternationalBookingResource {
    data: InternationalBookingResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class InternationalBookingResource implements IInternationalBookingResource {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    kindOfBooking: string | undefined;
    eta: moment.Moment | undefined;
    shipmentModeId: number | undefined;
    shipmentMode: ShipmentMode | undefined;
    shipmentDeliveryTypeId: number;
    shipmentDeliveryType: ShipmentDeliveryType | undefined;
    pickupContactName: string | undefined;
    pickupAddress: string | undefined;
    pickupContactPhone: string | undefined;
    country: string;
    isPaid: boolean | undefined;
    recipientName: string | undefined;
    deliveryAddress: string | undefined;
    recipientPhone: string | undefined;
    estimatedPackageWeight: number | undefined;
    actualPackageWeight: number | undefined;
    estimatedPackageSize: string | undefined;
    homeDelivery: boolean | undefined;
    homeDeliveryCharge: number | undefined;
    homeDeliveryLocationId: number | undefined;
    homeDeliveryLocation: Location | undefined;
    pickup: boolean | undefined;
    pickupCharge: number | undefined;
    pickupLocationId: number | undefined;
    pickupLocation: Location | undefined;
    shippingCost: number | undefined;
    exchangeRate: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    deletedAt: moment.Moment | undefined;
    bookingNumber: string | undefined;
    processNote: string | undefined;
    rejectionNote: string | undefined;
    hasHoldInstruction: boolean | undefined;
    holdInstruction: HoldInstruction | undefined;
    packageDescription: string;
    zipCode: number | undefined;
    postCode: number | undefined;
    localHomeDeliveryTypeId: number | undefined;
    localHomeDeliveryType: DeliveryType | undefined;
    carrier: string | undefined;
    trackingNumber: string | undefined;
    shippingBatchId: number | undefined;
    shippingBatch: ShippingBatch | undefined;
    receivedAt: moment.Moment | undefined;
    intlStatusTimeline: IntlStatusTimeline[] | undefined;
    bookingStatusId: number | undefined;
    bookingStatus: IntlBookingStatus | undefined;
    payments: Payment[] | undefined;
    initiatorId: string | undefined;
    packageValue: number | undefined;
    initiator: AspNetUser | undefined;

    constructor(data?: IInternationalBookingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.kindOfBooking = _data["kindOfBooking"];
            this.eta = _data["eta"] ? moment(_data["eta"].toString()) : <any>undefined;
            this.shipmentModeId = _data["shipmentModeId"];
            this.shipmentMode = _data["shipmentMode"] ? ShipmentMode.fromJS(_data["shipmentMode"]) : <any>undefined;
            this.shipmentDeliveryTypeId = _data["shipmentDeliveryTypeId"];
            this.shipmentDeliveryType = _data["shipmentDeliveryType"] ? ShipmentDeliveryType.fromJS(_data["shipmentDeliveryType"]) : <any>undefined;
            this.pickupContactName = _data["pickupContactName"];
            this.pickupAddress = _data["pickupAddress"];
            this.pickupContactPhone = _data["pickupContactPhone"];
            this.country = _data["country"];
            this.isPaid = _data["isPaid"];
            this.recipientName = _data["recipientName"];
            this.deliveryAddress = _data["deliveryAddress"];
            this.recipientPhone = _data["recipientPhone"];
            this.estimatedPackageWeight = _data["estimatedPackageWeight"];
            this.actualPackageWeight = _data["actualPackageWeight"];
            this.estimatedPackageSize = _data["estimatedPackageSize"];
            this.homeDelivery = _data["homeDelivery"];
            this.homeDeliveryCharge = _data["homeDeliveryCharge"];
            this.homeDeliveryLocationId = _data["homeDeliveryLocationId"];
            this.homeDeliveryLocation = _data["homeDeliveryLocation"] ? Location.fromJS(_data["homeDeliveryLocation"]) : <any>undefined;
            this.pickup = _data["pickup"];
            this.pickupCharge = _data["pickupCharge"];
            this.pickupLocationId = _data["pickupLocationId"];
            this.pickupLocation = _data["pickupLocation"] ? Location.fromJS(_data["pickupLocation"]) : <any>undefined;
            this.shippingCost = _data["shippingCost"];
            this.exchangeRate = _data["exchangeRate"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.bookingNumber = _data["bookingNumber"];
            this.processNote = _data["processNote"];
            this.rejectionNote = _data["rejectionNote"];
            this.hasHoldInstruction = _data["hasHoldInstruction"];
            this.holdInstruction = _data["holdInstruction"] ? HoldInstruction.fromJS(_data["holdInstruction"]) : <any>undefined;
            this.packageDescription = _data["packageDescription"];
            this.zipCode = _data["zipCode"];
            this.postCode = _data["postCode"];
            this.localHomeDeliveryTypeId = _data["localHomeDeliveryTypeId"];
            this.localHomeDeliveryType = _data["localHomeDeliveryType"] ? DeliveryType.fromJS(_data["localHomeDeliveryType"]) : <any>undefined;
            this.carrier = _data["carrier"];
            this.trackingNumber = _data["trackingNumber"];
            this.shippingBatchId = _data["shippingBatchId"];
            this.shippingBatch = _data["shippingBatch"] ? ShippingBatch.fromJS(_data["shippingBatch"]) : <any>undefined;
            this.receivedAt = _data["receivedAt"] ? moment(_data["receivedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["intlStatusTimeline"])) {
                this.intlStatusTimeline = [] as any;
                for (let item of _data["intlStatusTimeline"])
                    this.intlStatusTimeline.push(IntlStatusTimeline.fromJS(item));
            }
            this.bookingStatusId = _data["bookingStatusId"];
            this.bookingStatus = _data["bookingStatus"] ? IntlBookingStatus.fromJS(_data["bookingStatus"]) : <any>undefined;
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments.push(Payment.fromJS(item));
            }
            this.initiatorId = _data["initiatorId"];
            this.packageValue = _data["packageValue"];
            this.initiator = _data["initiator"] ? AspNetUser.fromJS(_data["initiator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InternationalBookingResource {
        data = typeof data === 'object' ? data : {};
        let result = new InternationalBookingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["kindOfBooking"] = this.kindOfBooking;
        data["eta"] = this.eta ? this.eta.toISOString() : <any>undefined;
        data["shipmentModeId"] = this.shipmentModeId;
        data["shipmentMode"] = this.shipmentMode ? this.shipmentMode.toJSON() : <any>undefined;
        data["shipmentDeliveryTypeId"] = this.shipmentDeliveryTypeId;
        data["shipmentDeliveryType"] = this.shipmentDeliveryType ? this.shipmentDeliveryType.toJSON() : <any>undefined;
        data["pickupContactName"] = this.pickupContactName;
        data["pickupAddress"] = this.pickupAddress;
        data["pickupContactPhone"] = this.pickupContactPhone;
        data["country"] = this.country;
        data["isPaid"] = this.isPaid;
        data["recipientName"] = this.recipientName;
        data["deliveryAddress"] = this.deliveryAddress;
        data["recipientPhone"] = this.recipientPhone;
        data["estimatedPackageWeight"] = this.estimatedPackageWeight;
        data["actualPackageWeight"] = this.actualPackageWeight;
        data["estimatedPackageSize"] = this.estimatedPackageSize;
        data["homeDelivery"] = this.homeDelivery;
        data["homeDeliveryCharge"] = this.homeDeliveryCharge;
        data["homeDeliveryLocationId"] = this.homeDeliveryLocationId;
        data["homeDeliveryLocation"] = this.homeDeliveryLocation ? this.homeDeliveryLocation.toJSON() : <any>undefined;
        data["pickup"] = this.pickup;
        data["pickupCharge"] = this.pickupCharge;
        data["pickupLocationId"] = this.pickupLocationId;
        data["pickupLocation"] = this.pickupLocation ? this.pickupLocation.toJSON() : <any>undefined;
        data["shippingCost"] = this.shippingCost;
        data["exchangeRate"] = this.exchangeRate;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["bookingNumber"] = this.bookingNumber;
        data["processNote"] = this.processNote;
        data["rejectionNote"] = this.rejectionNote;
        data["hasHoldInstruction"] = this.hasHoldInstruction;
        data["holdInstruction"] = this.holdInstruction ? this.holdInstruction.toJSON() : <any>undefined;
        data["packageDescription"] = this.packageDescription;
        data["zipCode"] = this.zipCode;
        data["postCode"] = this.postCode;
        data["localHomeDeliveryTypeId"] = this.localHomeDeliveryTypeId;
        data["localHomeDeliveryType"] = this.localHomeDeliveryType ? this.localHomeDeliveryType.toJSON() : <any>undefined;
        data["carrier"] = this.carrier;
        data["trackingNumber"] = this.trackingNumber;
        data["shippingBatchId"] = this.shippingBatchId;
        data["shippingBatch"] = this.shippingBatch ? this.shippingBatch.toJSON() : <any>undefined;
        data["receivedAt"] = this.receivedAt ? this.receivedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.intlStatusTimeline)) {
            data["intlStatusTimeline"] = [];
            for (let item of this.intlStatusTimeline)
                data["intlStatusTimeline"].push(item.toJSON());
        }
        data["bookingStatusId"] = this.bookingStatusId;
        data["bookingStatus"] = this.bookingStatus ? this.bookingStatus.toJSON() : <any>undefined;
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        data["initiatorId"] = this.initiatorId;
        data["packageValue"] = this.packageValue;
        data["initiator"] = this.initiator ? this.initiator.toJSON() : <any>undefined;
        return data; 
    }

    clone(): InternationalBookingResource {
        const json = this.toJSON();
        let result = new InternationalBookingResource();
        result.init(json);
        return result;
    }
}

export interface IInternationalBookingResource {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    kindOfBooking: string | undefined;
    eta: moment.Moment | undefined;
    shipmentModeId: number | undefined;
    shipmentMode: ShipmentMode | undefined;
    shipmentDeliveryTypeId: number;
    shipmentDeliveryType: ShipmentDeliveryType | undefined;
    pickupContactName: string | undefined;
    pickupAddress: string | undefined;
    pickupContactPhone: string | undefined;
    country: string;
    isPaid: boolean | undefined;
    recipientName: string | undefined;
    deliveryAddress: string | undefined;
    recipientPhone: string | undefined;
    estimatedPackageWeight: number | undefined;
    actualPackageWeight: number | undefined;
    estimatedPackageSize: string | undefined;
    homeDelivery: boolean | undefined;
    homeDeliveryCharge: number | undefined;
    homeDeliveryLocationId: number | undefined;
    homeDeliveryLocation: Location | undefined;
    pickup: boolean | undefined;
    pickupCharge: number | undefined;
    pickupLocationId: number | undefined;
    pickupLocation: Location | undefined;
    shippingCost: number | undefined;
    exchangeRate: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    deletedAt: moment.Moment | undefined;
    bookingNumber: string | undefined;
    processNote: string | undefined;
    rejectionNote: string | undefined;
    hasHoldInstruction: boolean | undefined;
    holdInstruction: HoldInstruction | undefined;
    packageDescription: string;
    zipCode: number | undefined;
    postCode: number | undefined;
    localHomeDeliveryTypeId: number | undefined;
    localHomeDeliveryType: DeliveryType | undefined;
    carrier: string | undefined;
    trackingNumber: string | undefined;
    shippingBatchId: number | undefined;
    shippingBatch: ShippingBatch | undefined;
    receivedAt: moment.Moment | undefined;
    intlStatusTimeline: IntlStatusTimeline[] | undefined;
    bookingStatusId: number | undefined;
    bookingStatus: IntlBookingStatus | undefined;
    payments: Payment[] | undefined;
    initiatorId: string | undefined;
    packageValue: number | undefined;
    initiator: AspNetUser | undefined;
}

export class ProcessILViewModelDTO implements IProcessILViewModelDTO {
    id: number | undefined;
    actualPackageWeight: number;
    model: InternationalBooking | undefined;
    homeDeliveryCost: number | undefined;
    pickupCharge: number | undefined;

    constructor(data?: IProcessILViewModelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.actualPackageWeight = _data["actualPackageWeight"];
            this.model = _data["model"] ? InternationalBooking.fromJS(_data["model"]) : <any>undefined;
            this.homeDeliveryCost = _data["homeDeliveryCost"];
            this.pickupCharge = _data["pickupCharge"];
        }
    }

    static fromJS(data: any): ProcessILViewModelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessILViewModelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["actualPackageWeight"] = this.actualPackageWeight;
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["homeDeliveryCost"] = this.homeDeliveryCost;
        data["pickupCharge"] = this.pickupCharge;
        return data; 
    }

    clone(): ProcessILViewModelDTO {
        const json = this.toJSON();
        let result = new ProcessILViewModelDTO();
        result.init(json);
        return result;
    }
}

export interface IProcessILViewModelDTO {
    id: number | undefined;
    actualPackageWeight: number;
    model: InternationalBooking | undefined;
    homeDeliveryCost: number | undefined;
    pickupCharge: number | undefined;
}

export class ObjectResourceOfProcessIntlBookingResource implements IObjectResourceOfProcessIntlBookingResource {
    data: ProcessIntlBookingResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfProcessIntlBookingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ProcessIntlBookingResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfProcessIntlBookingResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfProcessIntlBookingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfProcessIntlBookingResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfProcessIntlBookingResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfProcessIntlBookingResource {
    data: ProcessIntlBookingResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class ProcessIntlBookingResource implements IProcessIntlBookingResource {
    id: number | undefined;

    constructor(data?: IProcessIntlBookingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProcessIntlBookingResource {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessIntlBookingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): ProcessIntlBookingResource {
        const json = this.toJSON();
        let result = new ProcessIntlBookingResource();
        result.init(json);
        return result;
    }
}

export interface IProcessIntlBookingResource {
    id: number | undefined;
}

export class ObjectResourceOfIPagedListOfInternationalBookingResource implements IObjectResourceOfIPagedListOfInternationalBookingResource {
    data: InternationalBookingResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfIPagedListOfInternationalBookingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(InternationalBookingResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfIPagedListOfInternationalBookingResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfIPagedListOfInternationalBookingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfIPagedListOfInternationalBookingResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfIPagedListOfInternationalBookingResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfIPagedListOfInternationalBookingResource {
    data: InternationalBookingResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class ObjectResourceOfGetLocalBookingsForMobileResource implements IObjectResourceOfGetLocalBookingsForMobileResource {
    data: GetLocalBookingsForMobileResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfGetLocalBookingsForMobileResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? GetLocalBookingsForMobileResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfGetLocalBookingsForMobileResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfGetLocalBookingsForMobileResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfGetLocalBookingsForMobileResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfGetLocalBookingsForMobileResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfGetLocalBookingsForMobileResource {
    data: GetLocalBookingsForMobileResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class GetLocalBookingsForMobileResource implements IGetLocalBookingsForMobileResource {
    localBookings: LocalBooking[] | undefined;
    dispatcher: Dispatcher | undefined;

    constructor(data?: IGetLocalBookingsForMobileResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["localBookings"])) {
                this.localBookings = [] as any;
                for (let item of _data["localBookings"])
                    this.localBookings.push(LocalBooking.fromJS(item));
            }
            this.dispatcher = _data["dispatcher"] ? Dispatcher.fromJS(_data["dispatcher"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetLocalBookingsForMobileResource {
        data = typeof data === 'object' ? data : {};
        let result = new GetLocalBookingsForMobileResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.localBookings)) {
            data["localBookings"] = [];
            for (let item of this.localBookings)
                data["localBookings"].push(item.toJSON());
        }
        data["dispatcher"] = this.dispatcher ? this.dispatcher.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetLocalBookingsForMobileResource {
        const json = this.toJSON();
        let result = new GetLocalBookingsForMobileResource();
        result.init(json);
        return result;
    }
}

export interface IGetLocalBookingsForMobileResource {
    localBookings: LocalBooking[] | undefined;
    dispatcher: Dispatcher | undefined;
}

export class ListResourceOfLocalBookingCategoryResource implements IListResourceOfLocalBookingCategoryResource {
    total: number | undefined;
    data: LocalBookingCategoryResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfLocalBookingCategoryResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(LocalBookingCategoryResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfLocalBookingCategoryResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfLocalBookingCategoryResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfLocalBookingCategoryResource {
        const json = this.toJSON();
        let result = new ListResourceOfLocalBookingCategoryResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfLocalBookingCategoryResource {
    total: number | undefined;
    data: LocalBookingCategoryResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class LocalBookingCategoryResource implements ILocalBookingCategoryResource {
    id: number | undefined;
    name: string | undefined;
    toggleBookingActivation: boolean | undefined;

    constructor(data?: ILocalBookingCategoryResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.toggleBookingActivation = _data["toggleBookingActivation"];
        }
    }

    static fromJS(data: any): LocalBookingCategoryResource {
        data = typeof data === 'object' ? data : {};
        let result = new LocalBookingCategoryResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["toggleBookingActivation"] = this.toggleBookingActivation;
        return data; 
    }

    clone(): LocalBookingCategoryResource {
        const json = this.toJSON();
        let result = new LocalBookingCategoryResource();
        result.init(json);
        return result;
    }
}

export interface ILocalBookingCategoryResource {
    id: number | undefined;
    name: string | undefined;
    toggleBookingActivation: boolean | undefined;
}

export class ListResourceOfLocalBookingStatusResource implements IListResourceOfLocalBookingStatusResource {
    total: number | undefined;
    data: LocalBookingStatusResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfLocalBookingStatusResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(LocalBookingStatusResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfLocalBookingStatusResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfLocalBookingStatusResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfLocalBookingStatusResource {
        const json = this.toJSON();
        let result = new ListResourceOfLocalBookingStatusResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfLocalBookingStatusResource {
    total: number | undefined;
    data: LocalBookingStatusResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class LocalBookingStatusResource implements ILocalBookingStatusResource {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: ILocalBookingStatusResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LocalBookingStatusResource {
        data = typeof data === 'object' ? data : {};
        let result = new LocalBookingStatusResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): LocalBookingStatusResource {
        const json = this.toJSON();
        let result = new LocalBookingStatusResource();
        result.init(json);
        return result;
    }
}

export interface ILocalBookingStatusResource {
    id: number | undefined;
    name: string | undefined;
}

export class ListResourceOfLocalBookingCategoryGroupResource implements IListResourceOfLocalBookingCategoryGroupResource {
    total: number | undefined;
    data: LocalBookingCategoryGroupResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfLocalBookingCategoryGroupResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(LocalBookingCategoryGroupResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfLocalBookingCategoryGroupResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfLocalBookingCategoryGroupResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfLocalBookingCategoryGroupResource {
        const json = this.toJSON();
        let result = new ListResourceOfLocalBookingCategoryGroupResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfLocalBookingCategoryGroupResource {
    total: number | undefined;
    data: LocalBookingCategoryGroupResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class LocalBookingCategoryGroupResource implements ILocalBookingCategoryGroupResource {
    id: number | undefined;
    name: string | undefined;
    localBookingCategoryId: number | undefined;
    toggleBookingActivation: boolean | undefined;

    constructor(data?: ILocalBookingCategoryGroupResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.localBookingCategoryId = _data["localBookingCategoryId"];
            this.toggleBookingActivation = _data["toggleBookingActivation"];
        }
    }

    static fromJS(data: any): LocalBookingCategoryGroupResource {
        data = typeof data === 'object' ? data : {};
        let result = new LocalBookingCategoryGroupResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["localBookingCategoryId"] = this.localBookingCategoryId;
        data["toggleBookingActivation"] = this.toggleBookingActivation;
        return data; 
    }

    clone(): LocalBookingCategoryGroupResource {
        const json = this.toJSON();
        let result = new LocalBookingCategoryGroupResource();
        result.init(json);
        return result;
    }
}

export interface ILocalBookingCategoryGroupResource {
    id: number | undefined;
    name: string | undefined;
    localBookingCategoryId: number | undefined;
    toggleBookingActivation: boolean | undefined;
}

export class ListResourceOfDispatcherResource implements IListResourceOfDispatcherResource {
    total: number | undefined;
    data: DispatcherResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfDispatcherResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(DispatcherResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfDispatcherResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfDispatcherResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfDispatcherResource {
        const json = this.toJSON();
        let result = new ListResourceOfDispatcherResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfDispatcherResource {
    total: number | undefined;
    data: DispatcherResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class DispatcherResource implements IDispatcherResource {
    id: number | undefined;
    name: string | undefined;
    dispatcherStatusesId: number | undefined;

    constructor(data?: IDispatcherResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.dispatcherStatusesId = _data["dispatcherStatusesId"];
        }
    }

    static fromJS(data: any): DispatcherResource {
        data = typeof data === 'object' ? data : {};
        let result = new DispatcherResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["dispatcherStatusesId"] = this.dispatcherStatusesId;
        return data; 
    }

    clone(): DispatcherResource {
        const json = this.toJSON();
        let result = new DispatcherResource();
        result.init(json);
        return result;
    }
}

export interface IDispatcherResource {
    id: number | undefined;
    name: string | undefined;
    dispatcherStatusesId: number | undefined;
}

export class ListResourceOfCustomerActorResource implements IListResourceOfCustomerActorResource {
    total: number | undefined;
    data: CustomerActorResource[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfCustomerActorResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(CustomerActorResource.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfCustomerActorResource {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfCustomerActorResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfCustomerActorResource {
        const json = this.toJSON();
        let result = new ListResourceOfCustomerActorResource();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfCustomerActorResource {
    total: number | undefined;
    data: CustomerActorResource[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class CustomerActorResource implements ICustomerActorResource {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: ICustomerActorResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CustomerActorResource {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerActorResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): CustomerActorResource {
        const json = this.toJSON();
        let result = new CustomerActorResource();
        result.init(json);
        return result;
    }
}

export interface ICustomerActorResource {
    id: number | undefined;
    name: string | undefined;
}

export class ListResourceOfPaymentTypeResoiurce implements IListResourceOfPaymentTypeResoiurce {
    total: number | undefined;
    data: PaymentTypeResoiurce[] | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IListResourceOfPaymentTypeResoiurce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PaymentTypeResoiurce.fromJS(item));
            }
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ListResourceOfPaymentTypeResoiurce {
        data = typeof data === 'object' ? data : {};
        let result = new ListResourceOfPaymentTypeResoiurce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ListResourceOfPaymentTypeResoiurce {
        const json = this.toJSON();
        let result = new ListResourceOfPaymentTypeResoiurce();
        result.init(json);
        return result;
    }
}

export interface IListResourceOfPaymentTypeResoiurce {
    total: number | undefined;
    data: PaymentTypeResoiurce[] | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class PaymentTypeResoiurce implements IPaymentTypeResoiurce {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean | undefined;

    constructor(data?: IPaymentTypeResoiurce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PaymentTypeResoiurce {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTypeResoiurce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): PaymentTypeResoiurce {
        const json = this.toJSON();
        let result = new PaymentTypeResoiurce();
        result.init(json);
        return result;
    }
}

export interface IPaymentTypeResoiurce {
    id: number | undefined;
    name: string | undefined;
    isActive: boolean | undefined;
}

export class CreateLocalBookingDTO implements ICreateLocalBookingDTO {
    deliveryDate: moment.Moment;
    deliveryTypeId: number | undefined;
    estimatedPackageWeight: number | undefined;
    paymentTypeId: number | undefined;
    localBookingCategoryId: number | undefined;
    senderName: string;
    pickUpAddress: string;
    pickupLandmark: string | undefined;
    phoneNumber: string;
    recipientName: string;
    deliveryAddress: string;
    deliveryLandmark: string | undefined;
    recipientPhoneNumber: string;
    pickupLocationId: number | undefined;
    deliveryLocationId: number | undefined;
    packageDescription: string | undefined;
    isInsured: boolean | undefined;
    packageValue: number | undefined;
    deliveryCost: number | undefined;
    numberOfPackages: number | undefined;
    insuranceCost: number | undefined;
    totalCost: number | undefined;
    customerActorStateId: number | undefined;
    wantCashCollection: boolean | undefined;
    cashCollectionAmount: number | undefined;
    cashCollectionAccountNumber: string | undefined;

    constructor(data?: ICreateLocalBookingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryDate = _data["deliveryDate"] ? moment(_data["deliveryDate"].toString()) : <any>undefined;
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.estimatedPackageWeight = _data["estimatedPackageWeight"];
            this.paymentTypeId = _data["paymentTypeId"];
            this.localBookingCategoryId = _data["localBookingCategoryId"];
            this.senderName = _data["senderName"];
            this.pickUpAddress = _data["pickUpAddress"];
            this.pickupLandmark = _data["pickupLandmark"];
            this.phoneNumber = _data["phoneNumber"];
            this.recipientName = _data["recipientName"];
            this.deliveryAddress = _data["deliveryAddress"];
            this.deliveryLandmark = _data["deliveryLandmark"];
            this.recipientPhoneNumber = _data["recipientPhoneNumber"];
            this.pickupLocationId = _data["pickupLocationId"];
            this.deliveryLocationId = _data["deliveryLocationId"];
            this.packageDescription = _data["packageDescription"];
            this.isInsured = _data["isInsured"];
            this.packageValue = _data["packageValue"];
            this.deliveryCost = _data["deliveryCost"];
            this.numberOfPackages = _data["numberOfPackages"];
            this.insuranceCost = _data["insuranceCost"];
            this.totalCost = _data["totalCost"];
            this.customerActorStateId = _data["customerActorStateId"];
            this.wantCashCollection = _data["wantCashCollection"];
            this.cashCollectionAmount = _data["cashCollectionAmount"];
            this.cashCollectionAccountNumber = _data["cashCollectionAccountNumber"];
        }
    }

    static fromJS(data: any): CreateLocalBookingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLocalBookingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["estimatedPackageWeight"] = this.estimatedPackageWeight;
        data["paymentTypeId"] = this.paymentTypeId;
        data["localBookingCategoryId"] = this.localBookingCategoryId;
        data["senderName"] = this.senderName;
        data["pickUpAddress"] = this.pickUpAddress;
        data["pickupLandmark"] = this.pickupLandmark;
        data["phoneNumber"] = this.phoneNumber;
        data["recipientName"] = this.recipientName;
        data["deliveryAddress"] = this.deliveryAddress;
        data["deliveryLandmark"] = this.deliveryLandmark;
        data["recipientPhoneNumber"] = this.recipientPhoneNumber;
        data["pickupLocationId"] = this.pickupLocationId;
        data["deliveryLocationId"] = this.deliveryLocationId;
        data["packageDescription"] = this.packageDescription;
        data["isInsured"] = this.isInsured;
        data["packageValue"] = this.packageValue;
        data["deliveryCost"] = this.deliveryCost;
        data["numberOfPackages"] = this.numberOfPackages;
        data["insuranceCost"] = this.insuranceCost;
        data["totalCost"] = this.totalCost;
        data["customerActorStateId"] = this.customerActorStateId;
        data["wantCashCollection"] = this.wantCashCollection;
        data["cashCollectionAmount"] = this.cashCollectionAmount;
        data["cashCollectionAccountNumber"] = this.cashCollectionAccountNumber;
        return data; 
    }

    clone(): CreateLocalBookingDTO {
        const json = this.toJSON();
        let result = new CreateLocalBookingDTO();
        result.init(json);
        return result;
    }
}

export interface ICreateLocalBookingDTO {
    deliveryDate: moment.Moment;
    deliveryTypeId: number | undefined;
    estimatedPackageWeight: number | undefined;
    paymentTypeId: number | undefined;
    localBookingCategoryId: number | undefined;
    senderName: string;
    pickUpAddress: string;
    pickupLandmark: string | undefined;
    phoneNumber: string;
    recipientName: string;
    deliveryAddress: string;
    deliveryLandmark: string | undefined;
    recipientPhoneNumber: string;
    pickupLocationId: number | undefined;
    deliveryLocationId: number | undefined;
    packageDescription: string | undefined;
    isInsured: boolean | undefined;
    packageValue: number | undefined;
    deliveryCost: number | undefined;
    numberOfPackages: number | undefined;
    insuranceCost: number | undefined;
    totalCost: number | undefined;
    customerActorStateId: number | undefined;
    wantCashCollection: boolean | undefined;
    cashCollectionAmount: number | undefined;
    cashCollectionAccountNumber: string | undefined;
}

export class ObjectResourceOfLocalBookingResource implements IObjectResourceOfLocalBookingResource {
    data: LocalBookingResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfLocalBookingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LocalBookingResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfLocalBookingResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfLocalBookingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfLocalBookingResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfLocalBookingResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfLocalBookingResource {
    data: LocalBookingResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class LocalBookingResource implements ILocalBookingResource {
    bookingNumber: string | undefined;
    email: string | undefined;
    userId: string | undefined;

    constructor(data?: ILocalBookingResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingNumber = _data["bookingNumber"];
            this.email = _data["email"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): LocalBookingResource {
        data = typeof data === 'object' ? data : {};
        let result = new LocalBookingResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingNumber"] = this.bookingNumber;
        data["email"] = this.email;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): LocalBookingResource {
        const json = this.toJSON();
        let result = new LocalBookingResource();
        result.init(json);
        return result;
    }
}

export interface ILocalBookingResource {
    bookingNumber: string | undefined;
    email: string | undefined;
    userId: string | undefined;
}

export class ObjectResourceOfDetailResource implements IObjectResourceOfDetailResource {
    data: DetailResource | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfDetailResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DetailResource.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfDetailResource {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfDetailResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfDetailResource {
        const json = this.toJSON();
        let result = new ObjectResourceOfDetailResource();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfDetailResource {
    data: DetailResource | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class DetailResource implements IDetailResource {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    deliveryDate: moment.Moment | undefined;
    deliveryTypeId: number | undefined;
    deliveryType: DeliveryType | undefined;
    paymentTypeId: number | undefined;
    bookingStatusId: number | undefined;
    isAccepted: boolean | undefined;
    isRejected: boolean | undefined;
    isDispatched: boolean | undefined;
    isDelivered: boolean | undefined;
    isPaid: boolean | undefined;
    bookingNumber: string | undefined;
    bookingStatus: BookingStatus | undefined;
    paymentType: PaymentType | undefined;
    acceptanceNote: string | undefined;
    dispatchNote: string | undefined;
    rejectionNote: string | undefined;
    dispatcherId: number | undefined;
    dispatcher: Dispatcher | undefined;
    localRouteRateId: number | undefined;
    localRouteRate: LocalRouteRate | undefined;
    senderName: string | undefined;
    pickUpAddress: string | undefined;
    pickupLandmark: string | undefined;
    phoneNumber: string | undefined;
    actorPhoneNumber: string | undefined;
    recipientName: string | undefined;
    deliveryAddress: string | undefined;
    deliveryLandmark: string | undefined;
    recipientPhoneNumber: string | undefined;
    pickupLocationId: number | undefined;
    deliveryLocationId: number | undefined;
    pickupLocation: Location | undefined;
    deliveryLocation: Location | undefined;
    packageDescription: string | undefined;
    sizeDescription: string | undefined;
    isInsured: boolean | undefined;
    packageValue: number | undefined;
    deliveryCost: number | undefined;
    numberOfPackages: number | undefined;
    insuranceCost: number | undefined;
    totalCost: number | undefined;
    localBookingCategoryId: number | undefined;
    localBookingCategory: LocalBookingCategory | undefined;
    estimatedPackageWeight: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    deletedAt: moment.Moment | undefined;
    customerActorStateId: number | undefined;
    bulkOrderId: number | undefined;
    customerActorState: CustomerActorState | undefined;
    payments: Payment[] | undefined;
    bulkOrder: BulkOrder | undefined;
    enableCustomerCancel: boolean | undefined;
    email: string | undefined;
    dispatchRouteStatus: DispatchRouteStatus[] | undefined;
    bookedByPartner: boolean | undefined;
    wantCashCollection: boolean | undefined;
    cashCollectionAmount: number | undefined;
    cashCollectionAccountNumber: string | undefined;
    dispatchedAt: moment.Moment | undefined;
    deliveredAt: moment.Moment | undefined;
    createdFromEndpoint: boolean | undefined;
    personalizedLocalRateId: number | undefined;
    personalizedLocalRate: PersonalizedLocalRate | undefined;

    constructor(data?: IDetailResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            this.deliveryDate = _data["deliveryDate"] ? moment(_data["deliveryDate"].toString()) : <any>undefined;
            this.deliveryTypeId = _data["deliveryTypeId"];
            this.deliveryType = _data["deliveryType"] ? DeliveryType.fromJS(_data["deliveryType"]) : <any>undefined;
            this.paymentTypeId = _data["paymentTypeId"];
            this.bookingStatusId = _data["bookingStatusId"];
            this.isAccepted = _data["isAccepted"];
            this.isRejected = _data["isRejected"];
            this.isDispatched = _data["isDispatched"];
            this.isDelivered = _data["isDelivered"];
            this.isPaid = _data["isPaid"];
            this.bookingNumber = _data["bookingNumber"];
            this.bookingStatus = _data["bookingStatus"] ? BookingStatus.fromJS(_data["bookingStatus"]) : <any>undefined;
            this.paymentType = _data["paymentType"] ? PaymentType.fromJS(_data["paymentType"]) : <any>undefined;
            this.acceptanceNote = _data["acceptanceNote"];
            this.dispatchNote = _data["dispatchNote"];
            this.rejectionNote = _data["rejectionNote"];
            this.dispatcherId = _data["dispatcherId"];
            this.dispatcher = _data["dispatcher"] ? Dispatcher.fromJS(_data["dispatcher"]) : <any>undefined;
            this.localRouteRateId = _data["localRouteRateId"];
            this.localRouteRate = _data["localRouteRate"] ? LocalRouteRate.fromJS(_data["localRouteRate"]) : <any>undefined;
            this.senderName = _data["senderName"];
            this.pickUpAddress = _data["pickUpAddress"];
            this.pickupLandmark = _data["pickupLandmark"];
            this.phoneNumber = _data["phoneNumber"];
            this.actorPhoneNumber = _data["actorPhoneNumber"];
            this.recipientName = _data["recipientName"];
            this.deliveryAddress = _data["deliveryAddress"];
            this.deliveryLandmark = _data["deliveryLandmark"];
            this.recipientPhoneNumber = _data["recipientPhoneNumber"];
            this.pickupLocationId = _data["pickupLocationId"];
            this.deliveryLocationId = _data["deliveryLocationId"];
            this.pickupLocation = _data["pickupLocation"] ? Location.fromJS(_data["pickupLocation"]) : <any>undefined;
            this.deliveryLocation = _data["deliveryLocation"] ? Location.fromJS(_data["deliveryLocation"]) : <any>undefined;
            this.packageDescription = _data["packageDescription"];
            this.sizeDescription = _data["sizeDescription"];
            this.isInsured = _data["isInsured"];
            this.packageValue = _data["packageValue"];
            this.deliveryCost = _data["deliveryCost"];
            this.numberOfPackages = _data["numberOfPackages"];
            this.insuranceCost = _data["insuranceCost"];
            this.totalCost = _data["totalCost"];
            this.localBookingCategoryId = _data["localBookingCategoryId"];
            this.localBookingCategory = _data["localBookingCategory"] ? LocalBookingCategory.fromJS(_data["localBookingCategory"]) : <any>undefined;
            this.estimatedPackageWeight = _data["estimatedPackageWeight"];
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.customerActorStateId = _data["customerActorStateId"];
            this.bulkOrderId = _data["bulkOrderId"];
            this.customerActorState = _data["customerActorState"] ? CustomerActorState.fromJS(_data["customerActorState"]) : <any>undefined;
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments.push(Payment.fromJS(item));
            }
            this.bulkOrder = _data["bulkOrder"] ? BulkOrder.fromJS(_data["bulkOrder"]) : <any>undefined;
            this.enableCustomerCancel = _data["enableCustomerCancel"];
            this.email = _data["email"];
            if (Array.isArray(_data["dispatchRouteStatus"])) {
                this.dispatchRouteStatus = [] as any;
                for (let item of _data["dispatchRouteStatus"])
                    this.dispatchRouteStatus.push(DispatchRouteStatus.fromJS(item));
            }
            this.bookedByPartner = _data["bookedByPartner"];
            this.wantCashCollection = _data["wantCashCollection"];
            this.cashCollectionAmount = _data["cashCollectionAmount"];
            this.cashCollectionAccountNumber = _data["cashCollectionAccountNumber"];
            this.dispatchedAt = _data["dispatchedAt"] ? moment(_data["dispatchedAt"].toString()) : <any>undefined;
            this.deliveredAt = _data["deliveredAt"] ? moment(_data["deliveredAt"].toString()) : <any>undefined;
            this.createdFromEndpoint = _data["createdFromEndpoint"];
            this.personalizedLocalRateId = _data["personalizedLocalRateId"];
            this.personalizedLocalRate = _data["personalizedLocalRate"] ? PersonalizedLocalRate.fromJS(_data["personalizedLocalRate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DetailResource {
        data = typeof data === 'object' ? data : {};
        let result = new DetailResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["deliveryTypeId"] = this.deliveryTypeId;
        data["deliveryType"] = this.deliveryType ? this.deliveryType.toJSON() : <any>undefined;
        data["paymentTypeId"] = this.paymentTypeId;
        data["bookingStatusId"] = this.bookingStatusId;
        data["isAccepted"] = this.isAccepted;
        data["isRejected"] = this.isRejected;
        data["isDispatched"] = this.isDispatched;
        data["isDelivered"] = this.isDelivered;
        data["isPaid"] = this.isPaid;
        data["bookingNumber"] = this.bookingNumber;
        data["bookingStatus"] = this.bookingStatus ? this.bookingStatus.toJSON() : <any>undefined;
        data["paymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        data["acceptanceNote"] = this.acceptanceNote;
        data["dispatchNote"] = this.dispatchNote;
        data["rejectionNote"] = this.rejectionNote;
        data["dispatcherId"] = this.dispatcherId;
        data["dispatcher"] = this.dispatcher ? this.dispatcher.toJSON() : <any>undefined;
        data["localRouteRateId"] = this.localRouteRateId;
        data["localRouteRate"] = this.localRouteRate ? this.localRouteRate.toJSON() : <any>undefined;
        data["senderName"] = this.senderName;
        data["pickUpAddress"] = this.pickUpAddress;
        data["pickupLandmark"] = this.pickupLandmark;
        data["phoneNumber"] = this.phoneNumber;
        data["actorPhoneNumber"] = this.actorPhoneNumber;
        data["recipientName"] = this.recipientName;
        data["deliveryAddress"] = this.deliveryAddress;
        data["deliveryLandmark"] = this.deliveryLandmark;
        data["recipientPhoneNumber"] = this.recipientPhoneNumber;
        data["pickupLocationId"] = this.pickupLocationId;
        data["deliveryLocationId"] = this.deliveryLocationId;
        data["pickupLocation"] = this.pickupLocation ? this.pickupLocation.toJSON() : <any>undefined;
        data["deliveryLocation"] = this.deliveryLocation ? this.deliveryLocation.toJSON() : <any>undefined;
        data["packageDescription"] = this.packageDescription;
        data["sizeDescription"] = this.sizeDescription;
        data["isInsured"] = this.isInsured;
        data["packageValue"] = this.packageValue;
        data["deliveryCost"] = this.deliveryCost;
        data["numberOfPackages"] = this.numberOfPackages;
        data["insuranceCost"] = this.insuranceCost;
        data["totalCost"] = this.totalCost;
        data["localBookingCategoryId"] = this.localBookingCategoryId;
        data["localBookingCategory"] = this.localBookingCategory ? this.localBookingCategory.toJSON() : <any>undefined;
        data["estimatedPackageWeight"] = this.estimatedPackageWeight;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["customerActorStateId"] = this.customerActorStateId;
        data["bulkOrderId"] = this.bulkOrderId;
        data["customerActorState"] = this.customerActorState ? this.customerActorState.toJSON() : <any>undefined;
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        data["bulkOrder"] = this.bulkOrder ? this.bulkOrder.toJSON() : <any>undefined;
        data["enableCustomerCancel"] = this.enableCustomerCancel;
        data["email"] = this.email;
        if (Array.isArray(this.dispatchRouteStatus)) {
            data["dispatchRouteStatus"] = [];
            for (let item of this.dispatchRouteStatus)
                data["dispatchRouteStatus"].push(item.toJSON());
        }
        data["bookedByPartner"] = this.bookedByPartner;
        data["wantCashCollection"] = this.wantCashCollection;
        data["cashCollectionAmount"] = this.cashCollectionAmount;
        data["cashCollectionAccountNumber"] = this.cashCollectionAccountNumber;
        data["dispatchedAt"] = this.dispatchedAt ? this.dispatchedAt.toISOString() : <any>undefined;
        data["deliveredAt"] = this.deliveredAt ? this.deliveredAt.toISOString() : <any>undefined;
        data["createdFromEndpoint"] = this.createdFromEndpoint;
        data["personalizedLocalRateId"] = this.personalizedLocalRateId;
        data["personalizedLocalRate"] = this.personalizedLocalRate ? this.personalizedLocalRate.toJSON() : <any>undefined;
        return data; 
    }

    clone(): DetailResource {
        const json = this.toJSON();
        let result = new DetailResource();
        result.init(json);
        return result;
    }
}

export interface IDetailResource {
    id: number | undefined;
    userId: string | undefined;
    customer: Customer | undefined;
    deliveryDate: moment.Moment | undefined;
    deliveryTypeId: number | undefined;
    deliveryType: DeliveryType | undefined;
    paymentTypeId: number | undefined;
    bookingStatusId: number | undefined;
    isAccepted: boolean | undefined;
    isRejected: boolean | undefined;
    isDispatched: boolean | undefined;
    isDelivered: boolean | undefined;
    isPaid: boolean | undefined;
    bookingNumber: string | undefined;
    bookingStatus: BookingStatus | undefined;
    paymentType: PaymentType | undefined;
    acceptanceNote: string | undefined;
    dispatchNote: string | undefined;
    rejectionNote: string | undefined;
    dispatcherId: number | undefined;
    dispatcher: Dispatcher | undefined;
    localRouteRateId: number | undefined;
    localRouteRate: LocalRouteRate | undefined;
    senderName: string | undefined;
    pickUpAddress: string | undefined;
    pickupLandmark: string | undefined;
    phoneNumber: string | undefined;
    actorPhoneNumber: string | undefined;
    recipientName: string | undefined;
    deliveryAddress: string | undefined;
    deliveryLandmark: string | undefined;
    recipientPhoneNumber: string | undefined;
    pickupLocationId: number | undefined;
    deliveryLocationId: number | undefined;
    pickupLocation: Location | undefined;
    deliveryLocation: Location | undefined;
    packageDescription: string | undefined;
    sizeDescription: string | undefined;
    isInsured: boolean | undefined;
    packageValue: number | undefined;
    deliveryCost: number | undefined;
    numberOfPackages: number | undefined;
    insuranceCost: number | undefined;
    totalCost: number | undefined;
    localBookingCategoryId: number | undefined;
    localBookingCategory: LocalBookingCategory | undefined;
    estimatedPackageWeight: number | undefined;
    createdAt: moment.Moment | undefined;
    updatedAt: moment.Moment | undefined;
    deletedAt: moment.Moment | undefined;
    customerActorStateId: number | undefined;
    bulkOrderId: number | undefined;
    customerActorState: CustomerActorState | undefined;
    payments: Payment[] | undefined;
    bulkOrder: BulkOrder | undefined;
    enableCustomerCancel: boolean | undefined;
    email: string | undefined;
    dispatchRouteStatus: DispatchRouteStatus[] | undefined;
    bookedByPartner: boolean | undefined;
    wantCashCollection: boolean | undefined;
    cashCollectionAmount: number | undefined;
    cashCollectionAccountNumber: string | undefined;
    dispatchedAt: moment.Moment | undefined;
    deliveredAt: moment.Moment | undefined;
    createdFromEndpoint: boolean | undefined;
    personalizedLocalRateId: number | undefined;
    personalizedLocalRate: PersonalizedLocalRate | undefined;
}

export class EditLocalBookingViewModel implements IEditLocalBookingViewModel {
    estimatedPackageWeight: number | undefined;
    numberOfPackages: number | undefined;
    id: number | undefined;
    bookingNumber: string | undefined;
    pickupLocation: string | undefined;
    deliveryLocation: string | undefined;
    totalCost: number | undefined;
    categoryId: number | undefined;

    constructor(data?: IEditLocalBookingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.estimatedPackageWeight = _data["estimatedPackageWeight"];
            this.numberOfPackages = _data["numberOfPackages"];
            this.id = _data["id"];
            this.bookingNumber = _data["bookingNumber"];
            this.pickupLocation = _data["pickupLocation"];
            this.deliveryLocation = _data["deliveryLocation"];
            this.totalCost = _data["totalCost"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): EditLocalBookingViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new EditLocalBookingViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estimatedPackageWeight"] = this.estimatedPackageWeight;
        data["numberOfPackages"] = this.numberOfPackages;
        data["id"] = this.id;
        data["bookingNumber"] = this.bookingNumber;
        data["pickupLocation"] = this.pickupLocation;
        data["deliveryLocation"] = this.deliveryLocation;
        data["totalCost"] = this.totalCost;
        data["categoryId"] = this.categoryId;
        return data; 
    }

    clone(): EditLocalBookingViewModel {
        const json = this.toJSON();
        let result = new EditLocalBookingViewModel();
        result.init(json);
        return result;
    }
}

export interface IEditLocalBookingViewModel {
    estimatedPackageWeight: number | undefined;
    numberOfPackages: number | undefined;
    id: number | undefined;
    bookingNumber: string | undefined;
    pickupLocation: string | undefined;
    deliveryLocation: string | undefined;
    totalCost: number | undefined;
    categoryId: number | undefined;
}

export class ModifyLocalBookingViewModel implements IModifyLocalBookingViewModel {
    deliveryDate: moment.Moment;
    paymentTypeId: number;
    id: number | undefined;
    localBooking: LocalBooking | undefined;

    constructor(data?: IModifyLocalBookingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryDate = _data["deliveryDate"] ? moment(_data["deliveryDate"].toString()) : <any>undefined;
            this.paymentTypeId = _data["paymentTypeId"];
            this.id = _data["id"];
            this.localBooking = _data["localBooking"] ? LocalBooking.fromJS(_data["localBooking"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModifyLocalBookingViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModifyLocalBookingViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["paymentTypeId"] = this.paymentTypeId;
        data["id"] = this.id;
        data["localBooking"] = this.localBooking ? this.localBooking.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ModifyLocalBookingViewModel {
        const json = this.toJSON();
        let result = new ModifyLocalBookingViewModel();
        result.init(json);
        return result;
    }
}

export interface IModifyLocalBookingViewModel {
    deliveryDate: moment.Moment;
    paymentTypeId: number;
    id: number | undefined;
    localBooking: LocalBooking | undefined;
}

export class CancelLocalBookingViewModel implements ICancelLocalBookingViewModel {
    note: string;
    id: number | undefined;
    localBooking: LocalBooking | undefined;

    constructor(data?: ICancelLocalBookingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
            this.id = _data["id"];
            this.localBooking = _data["localBooking"] ? LocalBooking.fromJS(_data["localBooking"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CancelLocalBookingViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CancelLocalBookingViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        data["id"] = this.id;
        data["localBooking"] = this.localBooking ? this.localBooking.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CancelLocalBookingViewModel {
        const json = this.toJSON();
        let result = new CancelLocalBookingViewModel();
        result.init(json);
        return result;
    }
}

export interface ICancelLocalBookingViewModel {
    note: string;
    id: number | undefined;
    localBooking: LocalBooking | undefined;
}

export class ObjectResourceOfUserViewModel implements IObjectResourceOfUserViewModel {
    data: UserViewModel | undefined;
    code: string | undefined;
    message: string | undefined;

    constructor(data?: IObjectResourceOfUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UserViewModel.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ObjectResourceOfUserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectResourceOfUserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }

    clone(): ObjectResourceOfUserViewModel {
        const json = this.toJSON();
        let result = new ObjectResourceOfUserViewModel();
        result.init(json);
        return result;
    }
}

export interface IObjectResourceOfUserViewModel {
    data: UserViewModel | undefined;
    code: string | undefined;
    message: string | undefined;
}

export class UserViewModel implements IUserViewModel {
    totalLocalOrder: number | undefined;
    totalIntlOrder: number | undefined;
    totalCheckOutAssistanntlOrder: number | undefined;
    user: AspNetUser | undefined;

    constructor(data?: IUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalLocalOrder = _data["totalLocalOrder"];
            this.totalIntlOrder = _data["totalIntlOrder"];
            this.totalCheckOutAssistanntlOrder = _data["totalCheckOutAssistanntlOrder"];
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalLocalOrder"] = this.totalLocalOrder;
        data["totalIntlOrder"] = this.totalIntlOrder;
        data["totalCheckOutAssistanntlOrder"] = this.totalCheckOutAssistanntlOrder;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UserViewModel {
        const json = this.toJSON();
        let result = new UserViewModel();
        result.init(json);
        return result;
    }
}

export interface IUserViewModel {
    totalLocalOrder: number | undefined;
    totalIntlOrder: number | undefined;
    totalCheckOutAssistanntlOrder: number | undefined;
    user: AspNetUser | undefined;
}

export class ChangePasswordViewModel implements IChangePasswordViewModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword: string | undefined;

    constructor(data?: IChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }

    clone(): ChangePasswordViewModel {
        const json = this.toJSON();
        let result = new ChangePasswordViewModel();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordViewModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword: string | undefined;
}

export class UpdateUserViewModel implements IUpdateUserViewModel {
    fullName: string;
    email: string;
    homeAddress: string;
    residentialCountryId: number;
    residentialStateId: number;
    phoneNumber: string;
    businessName: string | undefined;
    closestLandmark: string | undefined;
    closestBustop: number | undefined;
    businessAnniversary: moment.Moment | undefined;

    constructor(data?: IUpdateUserViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.homeAddress = _data["homeAddress"];
            this.residentialCountryId = _data["residentialCountryId"];
            this.residentialStateId = _data["residentialStateId"];
            this.phoneNumber = _data["phoneNumber"];
            this.businessName = _data["businessName"];
            this.closestLandmark = _data["closestLandmark"];
            this.closestBustop = _data["closestBustop"];
            this.businessAnniversary = _data["businessAnniversary"] ? moment(_data["businessAnniversary"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateUserViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["homeAddress"] = this.homeAddress;
        data["residentialCountryId"] = this.residentialCountryId;
        data["residentialStateId"] = this.residentialStateId;
        data["phoneNumber"] = this.phoneNumber;
        data["businessName"] = this.businessName;
        data["closestLandmark"] = this.closestLandmark;
        data["closestBustop"] = this.closestBustop;
        data["businessAnniversary"] = this.businessAnniversary ? this.businessAnniversary.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UpdateUserViewModel {
        const json = this.toJSON();
        let result = new UpdateUserViewModel();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserViewModel {
    fullName: string;
    email: string;
    homeAddress: string;
    residentialCountryId: number;
    residentialStateId: number;
    phoneNumber: string;
    businessName: string | undefined;
    closestLandmark: string | undefined;
    closestBustop: number | undefined;
    businessAnniversary: moment.Moment | undefined;
}

export class ForgotPasswordViewModel implements IForgotPasswordViewModel {
    email: string;

    constructor(data?: IForgotPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }

    clone(): ForgotPasswordViewModel {
        const json = this.toJSON();
        let result = new ForgotPasswordViewModel();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordViewModel {
    email: string;
}

export class SelectedOrder implements ISelectedOrder {
    input: string | undefined;

    constructor(data?: ISelectedOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.input = _data["input"];
        }
    }

    static fromJS(data: any): SelectedOrder {
        data = typeof data === 'object' ? data : {};
        let result = new SelectedOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["input"] = this.input;
        return data; 
    }

    clone(): SelectedOrder {
        const json = this.toJSON();
        let result = new SelectedOrder();
        result.init(json);
        return result;
    }
}

export interface ISelectedOrder {
    input: string | undefined;
}

export enum LoginResourceUserType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum RegisterUserVieModelUserType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum RegisterUserResourceUserType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}